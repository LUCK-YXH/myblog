<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Flutter创建App 闪屏</title>
    <link href="/myblog/2024/11/01/f-splash/"/>
    <url>/myblog/2024/11/01/f-splash/</url>
    
    <content type="html"><![CDATA[<h2 id="Flutter添加一个App-闪屏"><a href="#Flutter添加一个App-闪屏" class="headerlink" title="Flutter添加一个App 闪屏"></a>Flutter添加一个App 闪屏</h2><p>flutter的插件flutter_native_splash 可以根据自定义的背景色和图片生成app 闪屏。</p><h3 id="1-首先，将flutter-native-splash作为依赖项添加到您的pubspec-yaml文件中。然后执行flutter-pub-get"><a href="#1-首先，将flutter-native-splash作为依赖项添加到您的pubspec-yaml文件中。然后执行flutter-pub-get" class="headerlink" title="1.首先，将flutter_native_splash作为依赖项添加到您的pubspec.yaml文件中。然后执行flutter pub get"></a>1.首先，将flutter_native_splash作为依赖项添加到您的pubspec.yaml文件中。然后执行<code>flutter pub get</code></h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">dependencies</span>:<br>  <span class="hljs-attribute">flutter_native_splash</span>: ^<span class="hljs-number">2</span>.<span class="hljs-number">4</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="2-自定义以下设置，并添加到项目的pubspec-yaml文件中，或放置在根项目文件夹中名为flutter-native-splash-yaml的新文件中。"><a href="#2-自定义以下设置，并添加到项目的pubspec-yaml文件中，或放置在根项目文件夹中名为flutter-native-splash-yaml的新文件中。" class="headerlink" title="2.自定义以下设置，并添加到项目的pubspec.yaml文件中，或放置在根项目文件夹中名为flutter_native_splash.yaml的新文件中。"></a>2.自定义以下设置，并添加到项目的pubspec.yaml文件中，或放置在根项目文件夹中名为flutter_native_splash.yaml的新文件中。</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">flutter_native_splash:</span><br>  <span class="hljs-comment"># This package generates native code to customize Flutter&#x27;s default white native splash screen</span><br>  <span class="hljs-comment"># with background color and splash image.</span><br>  <span class="hljs-comment"># Customize the parameters below, and run the following command in the terminal:</span><br>  <span class="hljs-comment"># dart run flutter_native_splash:create</span><br>  <span class="hljs-comment"># To restore Flutter&#x27;s default white splash screen, run the following command in the terminal:</span><br>  <span class="hljs-comment"># dart run flutter_native_splash:remove</span><br><br>  <span class="hljs-comment"># IMPORTANT NOTE: These parameter do not affect the configuration of Android 12 and later, which</span><br>  <span class="hljs-comment"># handle splash screens differently that prior versions of Android.  Android 12 and later must be</span><br>  <span class="hljs-comment"># configured specifically in the android_12 section below.</span><br><br>  <span class="hljs-comment"># color or background_image is the only required parameter.  Use color to set the background</span><br>  <span class="hljs-comment"># of your splash screen to a solid color.  Use background_image to set the background of your</span><br>  <span class="hljs-comment"># splash screen to a png image.  This is useful for gradients. The image will be stretch to the</span><br>  <span class="hljs-comment"># size of the app. Only one parameter can be used, color and background_image cannot both be set.</span><br>  <span class="hljs-attr">color:</span> <span class="hljs-string">&quot;#42a5f5&quot;</span><br>  <span class="hljs-comment">#background_image: &quot;assets/background.png&quot;</span><br><br>  <span class="hljs-comment"># Optional parameters are listed below.  To enable a parameter, uncomment the line by removing</span><br>  <span class="hljs-comment"># the leading # character.</span><br><br>  <span class="hljs-comment"># The image parameter allows you to specify an image used in the splash screen.  It must be a</span><br>  <span class="hljs-comment"># png file and should be sized for 4x pixel density.</span><br>  <span class="hljs-comment">#image: assets/splash.png</span><br><br>  <span class="hljs-comment"># The branding property allows you to specify an image used as branding in the splash screen.</span><br>  <span class="hljs-comment"># It must be a png file. It is supported for Android, iOS and the Web.  For Android 12,</span><br>  <span class="hljs-comment"># see the Android 12 section below.</span><br>  <span class="hljs-comment">#branding: assets/dart.png</span><br><br>  <span class="hljs-comment"># To position the branding image at the bottom of the screen you can use bottom, bottomRight,</span><br>  <span class="hljs-comment"># and bottomLeft. The default values is bottom if not specified or specified something else.</span><br>  <span class="hljs-comment">#branding_mode: bottom</span><br>  <br>  <span class="hljs-comment"># Set the branding padding from the bottom of the screen.  The default value is 0</span><br>  <span class="hljs-comment"># branding_bottom_padding: 24</span><br><br>  <span class="hljs-comment"># The color_dark, background_image_dark, image_dark, branding_dark are parameters that set the background</span><br>  <span class="hljs-comment"># and image when the device is in dark mode. If they are not specified, the app will use the</span><br>  <span class="hljs-comment"># parameters from above. If the image_dark parameter is specified, color_dark or</span><br>  <span class="hljs-comment"># background_image_dark must be specified.  color_dark and background_image_dark cannot both be</span><br>  <span class="hljs-comment"># set.</span><br>  <span class="hljs-comment">#color_dark: &quot;#042a49&quot;</span><br>  <span class="hljs-comment">#background_image_dark: &quot;assets/dark-background.png&quot;</span><br>  <span class="hljs-comment">#image_dark: assets/splash-invert.png</span><br>  <span class="hljs-comment">#branding_dark: assets/dart_dark.png</span><br><br>  <span class="hljs-comment"># From Android 12 onwards, the splash screen is handled differently than in previous versions.</span><br>  <span class="hljs-comment"># Please visit https://developer.android.com/guide/topics/ui/splash-screen</span><br>  <span class="hljs-comment"># Following are specific parameters for Android 12+.</span><br>  <span class="hljs-attr">android_12:</span><br>    <span class="hljs-comment"># The image parameter sets the splash screen icon image.  If this parameter is not specified,</span><br>    <span class="hljs-comment"># the app&#x27;s launcher icon will be used instead.</span><br>    <span class="hljs-comment"># Please note that the splash screen will be clipped to a circle on the center of the screen.</span><br>    <span class="hljs-comment"># App icon with an icon background: This should be 960×960 pixels, and fit within a circle</span><br>    <span class="hljs-comment"># 640 pixels in diameter.</span><br>    <span class="hljs-comment"># App icon without an icon background: This should be 1152×1152 pixels, and fit within a circle</span><br>    <span class="hljs-comment"># 768 pixels in diameter.  To fit a 1152x1152 image within a circle with a 768 diameter, simply </span><br>    <span class="hljs-comment"># ensure that the most important design elements of your image are placed within a circular area</span><br>    <span class="hljs-comment"># with a 768 diameter at the center of the 1152x1152 canvas.</span><br>    <span class="hljs-string">///闪屏图片</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">assets/icon/notes.png</span><br><br>    <span class="hljs-comment"># Splash screen background color.</span><br>    <span class="hljs-comment">#color: &quot;#42a5f5&quot;</span><br><br>    <span class="hljs-comment"># App icon background color.</span><br>    <span class="hljs-comment">#icon_background_color: &quot;#111111&quot;</span><br><br>    <span class="hljs-comment"># The branding property allows you to specify an image used as branding in the splash screen.</span><br>    <span class="hljs-comment">#branding: assets/dart.png</span><br><br>    <span class="hljs-comment"># The image_dark, color_dark, icon_background_color_dark, and branding_dark set values that</span><br>    <span class="hljs-comment"># apply when the device is in dark mode. If they are not specified, the app will use the</span><br>    <span class="hljs-comment"># parameters from above.</span><br>    <span class="hljs-comment">#image_dark: assets/android12splash-invert.png</span><br>    <span class="hljs-comment">#color_dark: &quot;#042a49&quot;</span><br>    <span class="hljs-comment">#icon_background_color_dark: &quot;#eeeeee&quot;</span><br><br>  <span class="hljs-comment"># The android, ios and web parameters can be used to disable generating a splash screen on a given</span><br>  <span class="hljs-comment"># platform.</span><br>  <span class="hljs-comment">#android: false</span><br>  <span class="hljs-comment">#ios: false</span><br>  <span class="hljs-comment">#web: false</span><br><br>  <span class="hljs-comment"># Platform specific images can be specified with the following parameters, which will override</span><br>  <span class="hljs-comment"># the respective parameter.  You may specify all, selected, or none of these parameters:</span><br>  <span class="hljs-comment">#color_android: &quot;#42a5f5&quot;</span><br>  <span class="hljs-comment">#color_dark_android: &quot;#042a49&quot;</span><br>  <span class="hljs-comment">#color_ios: &quot;#42a5f5&quot;</span><br>  <span class="hljs-comment">#color_dark_ios: &quot;#042a49&quot;</span><br>  <span class="hljs-comment">#color_web: &quot;#42a5f5&quot;</span><br>  <span class="hljs-comment">#color_dark_web: &quot;#042a49&quot;</span><br>  <span class="hljs-comment">#image_android: assets/splash-android.png</span><br>  <span class="hljs-comment">#image_dark_android: assets/splash-invert-android.png</span><br>  <span class="hljs-comment">#image_ios: assets/splash-ios.png</span><br>  <span class="hljs-comment">#image_dark_ios: assets/splash-invert-ios.png</span><br>  <span class="hljs-comment">#image_web: assets/splash-web.gif</span><br>  <span class="hljs-comment">#image_dark_web: assets/splash-invert-web.gif</span><br>  <span class="hljs-comment">#background_image_android: &quot;assets/background-android.png&quot;</span><br>  <span class="hljs-comment">#background_image_dark_android: &quot;assets/dark-background-android.png&quot;</span><br>  <span class="hljs-comment">#background_image_ios: &quot;assets/background-ios.png&quot;</span><br>  <span class="hljs-comment">#background_image_dark_ios: &quot;assets/dark-background-ios.png&quot;</span><br>  <span class="hljs-comment">#background_image_web: &quot;assets/background-web.png&quot;</span><br>  <span class="hljs-comment">#background_image_dark_web: &quot;assets/dark-background-web.png&quot;</span><br>  <span class="hljs-comment">#branding_android: assets/brand-android.png</span><br>  <span class="hljs-comment">#branding_bottom_padding_android: 24</span><br>  <span class="hljs-comment">#branding_dark_android: assets/dart_dark-android.png</span><br>  <span class="hljs-comment">#branding_ios: assets/brand-ios.png</span><br>  <span class="hljs-comment">#branding_bottom_padding_ios: 24</span><br>  <span class="hljs-comment">#branding_dark_ios: assets/dart_dark-ios.png</span><br>  <span class="hljs-comment">#branding_web: assets/brand-web.gif</span><br>  <span class="hljs-comment">#branding_dark_web: assets/dart_dark-web.gif</span><br><br>  <span class="hljs-comment"># The position of the splash image can be set with android_gravity, ios_content_mode, and</span><br>  <span class="hljs-comment"># web_image_mode parameters.  All default to center.</span><br>  <span class="hljs-comment">#</span><br>  <span class="hljs-comment"># android_gravity can be one of the following Android Gravity (see</span><br>  <span class="hljs-comment"># https://developer.android.com/reference/android/view/Gravity): bottom, center,</span><br>  <span class="hljs-comment"># center_horizontal, center_vertical, clip_horizontal, clip_vertical, end, fill, fill_horizontal,</span><br>  <span class="hljs-comment"># fill_vertical, left, right, start, or top.</span><br>  <span class="hljs-comment">#android_gravity: center</span><br>  <span class="hljs-comment">#</span><br>  <span class="hljs-comment"># ios_content_mode can be one of the following iOS UIView.ContentMode (see</span><br>  <span class="hljs-comment"># https://developer.apple.com/documentation/uikit/uiview/contentmode): scaleToFill,</span><br>  <span class="hljs-comment"># scaleAspectFit, scaleAspectFill, center, top, bottom, left, right, topLeft, topRight,</span><br>  <span class="hljs-comment"># bottomLeft, or bottomRight.</span><br>  <span class="hljs-comment">#ios_content_mode: center</span><br>  <span class="hljs-comment">#</span><br>  <span class="hljs-comment"># web_image_mode can be one of the following modes: center, contain, stretch, and cover.</span><br>  <span class="hljs-comment">#web_image_mode: center</span><br><br>  <span class="hljs-comment"># The screen orientation can be set in Android with the android_screen_orientation parameter.</span><br>  <span class="hljs-comment"># Valid parameters can be found here:</span><br>  <span class="hljs-comment"># https://developer.android.com/guide/topics/manifest/activity-element#screen</span><br>  <span class="hljs-comment">#android_screen_orientation: sensorLandscape</span><br><br>  <span class="hljs-comment"># To hide the notification bar, use the fullscreen parameter.  Has no effect in web since web</span><br>  <span class="hljs-comment"># has no notification bar.  Defaults to false.</span><br>  <span class="hljs-comment"># <span class="hljs-doctag">NOTE:</span> Unlike Android, iOS will not automatically show the notification bar when the app loads.</span><br>  <span class="hljs-comment">#       To show the notification bar, add the following code to your Flutter app:</span><br>  <span class="hljs-comment">#       WidgetsFlutterBinding.ensureInitialized();</span><br>  <span class="hljs-comment">#       SystemChrome.setEnabledSystemUIMode(SystemUiMode.manual, overlays: [SystemUiOverlay.bottom, SystemUiOverlay.top], );</span><br>  <span class="hljs-comment">#fullscreen: true</span><br><br>  <span class="hljs-comment"># If you have changed the name(s) of your info.plist file(s), you can specify the filename(s)</span><br>  <span class="hljs-comment"># with the info_plist_files parameter.  Remove only the # characters in the three lines below,</span><br>  <span class="hljs-comment"># do not remove any spaces:</span><br>  <span class="hljs-comment">#info_plist_files:</span><br>  <span class="hljs-comment">#  - &#x27;ios/Runner/Info-Debug.plist&#x27;</span><br>  <span class="hljs-comment">#  - &#x27;ios/Runner/Info-Release.plist&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="3-将设置添加到pubspec-yaml后，在终端中运行以下命令："><a href="#3-将设置添加到pubspec-yaml后，在终端中运行以下命令：" class="headerlink" title="3.将设置添加到pubspec.yaml后，在终端中运行以下命令："></a>3.将设置添加到pubspec.yaml后，在终端中运行以下命令：</h3><p><code>dart run flutter_native_splash:create</code><br>当软件包运行完时，您的启动屏幕就准备好了。</p>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flutter_学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter创建App Icon</title>
    <link href="/myblog/2024/11/01/f-launcher-icons/"/>
    <url>/myblog/2024/11/01/f-launcher-icons/</url>
    
    <content type="html"><![CDATA[<h2 id="Flutter添加一个App-Icon"><a href="#Flutter添加一个App-Icon" class="headerlink" title="Flutter添加一个App Icon"></a>Flutter添加一个App Icon</h2><p>flutter的插件flutter_launcher_icons可以根据给定的图片自动生成不同分辨率的应用图标</p><h3 id="1-需要准备一张1024-1024的图片，把图片放到一个目录中。没有就新建一个。如（assets-icon-notes-png）"><a href="#1-需要准备一张1024-1024的图片，把图片放到一个目录中。没有就新建一个。如（assets-icon-notes-png）" class="headerlink" title="1. 需要准备一张1024*1024的图片，把图片放到一个目录中。没有就新建一个。如（assets&#x2F;icon&#x2F;notes.png）"></a>1. 需要准备一张1024*1024的图片，把图片放到一个目录中。没有就新建一个。如（assets&#x2F;icon&#x2F;notes.png）</h3><h3 id="2-引入flutter-launcher-icons插件"><a href="#2-引入flutter-launcher-icons插件" class="headerlink" title="2. 引入flutter_launcher_icons插件"></a>2. 引入flutter_launcher_icons插件</h3><p>在pubspec.yaml文件中的dev_dependencies下配置依赖</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">flutter_icons:</span><br>  <span class="hljs-attr">android:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">ios:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">image_path:</span> <span class="hljs-string">&quot;assets/icon/notes.png&quot;</span><br></code></pre></td></tr></table></figure><h3 id="3-配置插件"><a href="#3-配置插件" class="headerlink" title="3. 配置插件"></a>3. 配置插件</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">dev_dependencies:</span><br><span class="hljs-symbol">  flutter_test:</span><br><span class="hljs-symbol">    sdk:</span> flutter<br><span class="hljs-symbol">  flutter_launcher_icons:</span> ^<span class="hljs-number">0.7</span><span class="hljs-number">.4</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">flutter_icons:</span><br><span class="hljs-symbol">  android:</span> <span class="hljs-string">&quot;ic_launcher&quot;</span><br><span class="hljs-symbol">  ios:</span> false<br><span class="hljs-symbol">  image_path:</span> <span class="hljs-string">&quot;assets/icon/notes.png&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>注意： flutter_icons与dev_dependencies是同级配置</p><p>android:ic_launcher 表示生成android平台的应用图标的名称<br>ios:false 表示不生成ios的图标<br>image_path 为源图片的路径</p></blockquote><h3 id="4-运行命令"><a href="#4-运行命令" class="headerlink" title="4. 运行命令"></a>4. 运行命令</h3><p>在工程的根目录下运行命令</p><ul><li>运行 flutter pub get 拉取依赖<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">flutter pub <span class="hljs-keyword">get</span><br></code></pre></td></tr></table></figure></li><li>运行 flutter pub run flutter_launcher_icons:main 生成图片<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">flutter pub <span class="hljs-built_in">run</span> flutter_launcher_icons:main<br></code></pre></td></tr></table></figure>命令运行成功后会自动的生成对应尺寸的应用图标。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flutter_学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Closures</title>
    <link href="/myblog/2024/10/29/Closures/"/>
    <url>/myblog/2024/10/29/Closures/</url>
    
    <content type="html"><![CDATA[<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是自包含的函数代码块，可以自代码中被传递和使用。Swift中的闭包与C和Objective-C中的代码块（blocks）以及其他一些编程语言中匿名函数（Lambdas）比较相似。</p><p>闭包可以捕获和存储其所在上下文中的任意常量和变量的引用。被称为包裹常量和变量。Swift会为你管理在捕获过程中涉及到的所有内存操作。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**注意**</span><br><br>如果你不熟悉捕获（capturing）这个概念也不用担心，<br>在下面值捕获中有更详细的介绍。<br></code></pre></td></tr></table></figure><p>在函数中介绍的全局和嵌套函数其实也是特殊闭包，闭包采用如下三种形式之一：</p><ul><li>全局函数是一个有名字但不会捕获任何值的闭包</li><li>嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包</li><li>闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中的变量或常量值的匿名闭包</li></ul><p>Swift的闭包表达式拥有简洁的风格，并鼓励在常见场景中进行语法优化，主要优化如下：</p><ul><li>利用上下文推断参数和返回值类型</li><li>隐式返回但表达式闭包，即单表达式闭包可以省略return关键字</li><li>参数名称缩写</li><li>尾随闭包语法</li></ul><h2 id="闭包表达式"><a href="#闭包表达式" class="headerlink" title="闭包表达式"></a>闭包表达式</h2><p>嵌套函数作为复杂函数的一部分时，它自包含代码块式的定义和命名形式在使用上带来了方便。当然编写为完整声明和没有函数名的类函数结构代码是很有用的，尤其是在编码中涉及到函数作为参数的那些方法时。</p><p>闭包表达式是一种构建内联闭包的方式，它的语法简洁。在保证不丢失它语法清晰明了的同时，闭包表达式提供了集中优化的语法简写形式。下面通过对<code>sorted(by:)</code>这一个案例的多次迭代改进来展示这个过程，每次迭代都使用了更加简明的方式描述了相同功能。</p><h2 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h2><p>Swift标准库提供了名为<code>sorted(by:)</code>的方法，它会基于你提供的排序闭包表达式的判断结果对数组中的值（类型确定）进行排序。一旦它完成排序过程，<code>sorted(by:)</code>方法会返回一个与旧数组类型大小相同类型的新数组，该数组的元素有着正确的排序顺序。原数组不会被<code>sorted(by:)</code>方法修改。</p><p>下面的闭包表达式示例使用<code>sorted(by:)</code>方法对一个String类型的数组进行字母逆序排序。以下是初始数组：</p><p><code>let names = [&quot;Chris&quot;, &quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;] </code><br><code>sorted(by:)</code>方法接受一个闭包，该闭包函数需要传入与数组元素类型相同的两个值，并返回一个布尔类型值来表明当排序结束后传入的第一个参数排在第二个参数前面还是后面。如果第一个参数值出现在第二个参数值前面，排序闭包函数需要放回true, 反之返回false。</p><p>该例子对一个 <code>String</code> 类型的数组进行排序，因此排序闭包函数类型需为<code>(String, String) -&gt; Bool</code>。</p><p>提供排序闭包函数的一种方式是撰写一个符合其类型要求的普通函数，并将其作为 <code>sorted(by:)</code> 方法的参数传入：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs julia">func backward(_ s1: <span class="hljs-built_in">String</span>, _ s2: <span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">Bool</span> &#123;<br>    <span class="hljs-keyword">return</span> s1 &gt; s2<br>&#125;<br>var reversedNames = names.sorted(by: backward)<br>// reversedNames 为 [<span class="hljs-string">&quot;Ewa&quot;</span>, <span class="hljs-string">&quot;Daniella&quot;</span>, <span class="hljs-string">&quot;Chris&quot;</span>, <span class="hljs-string">&quot;Barry&quot;</span>, <span class="hljs-string">&quot;Alex&quot;</span>]<br><br></code></pre></td></tr></table></figure><p>如果第一个字符串<code>（s1）</code>大于第二个字符串<code>（s2）</code>，<code>backward(_:_:)</code> 函数会返回 <code>true</code>，表示在新的数组中 <code>s1 </code>应该出现在 <code>s2</code> 前。对于字符串中的字符来说，“大于”表示“按照字母顺序较晚出现”。这意味着字母 <code>&quot;B&quot;</code> 大于字母 <code>&quot;A&quot; </code>，字符串 <code>&quot;Tom&quot;</code> 大于字符串<code>&quot;Tim&quot;</code>。该闭包将进行字母逆序排序，<code>&quot;Barry&quot; </code>将会排在 <code>&quot;Alex&quot;</code> 之前。</p><p>然而，以这种方式来编写一个实际上很简单的表达式<code>（a &gt; b)</code>，确实太过繁琐了。对于这个例子来说，利用闭包表达式语法可以更好地构造一个内联排序闭包。</p><h2 id="闭包表达式语法"><a href="#闭包表达式语法" class="headerlink" title="闭包表达式语法"></a>闭包表达式语法</h2><p>闭包表达式语法有如下的一般形式：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript">&#123; <span class="hljs-function"><span class="hljs-params">(parameters)</span> -&gt;</span> <span class="hljs-keyword">return</span> type <span class="hljs-keyword">in</span><br>    statements<br>&#125;<br></code></pre></td></tr></table></figure><p>闭包表达式参数 可以是 in-out 参数，但不能设定默认值。如果你命名了可变参数，也可以使用此可变参数。元组也可以作为参数和返回值。</p><p>下面的例子展示了之前 <code>backward(_:_:)</code> 函数对应的闭包表达式版本的代码：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript">reversedNames = names.sorted<span class="hljs-function"><span class="hljs-params">(<span class="hljs-keyword">by</span>: &#123; (s1: <span class="hljs-built_in">String</span>, s2: <span class="hljs-built_in">String</span>) -&gt; Bool <span class="hljs-keyword">in</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">return</span> s1 &gt; s2</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span></span><br></code></pre></td></tr></table></figure><p>需要注意的是内联闭包参数和返回值类型声明与   <code>backward(_:_:)</code> 函数类型声明相同。在这两种方式中，都写成了 <code>(s1: String, s2: String) -&gt; Bool</code>。然而在内联闭包表达式中，函数和返回值类型都写在大括号内，而不是大括号外。<br>闭包的函数体部分由关键字<code>in</code>引入。该关键字表示闭包的参数和返回值类型定义已经完成，闭包函数体即将开始。<br>由于这个闭包的函数体部分如此短，以至于可以将其改写成一行代码：</p><p><code>reversedNames = names.sorted(by: &#123; (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2 &#125; ) </code></p><p>该例中<code>sorted(by:)</code> 方法的整体调用保持不变，一对圆括号仍然包裹住了方法的整个参数。然而，参数现在变成了内联闭包。</p><h2 id="根据上下文推断类型"><a href="#根据上下文推断类型" class="headerlink" title="根据上下文推断类型"></a>根据上下文推断类型</h2><p>因为排序闭包函数是作为 <code>sorted(by:)</code> 方法的参数传入的，<code>Swift</code> 可以推断其参数和返回值的类型。<code>sorted(by:)</code> 方法被一个字符串数组调用，因此其参数必须是 <code>(String, String) -&gt; Bool </code>类型的函数。这意味着 <code>(String, String) </code>和 <code>Bool </code>类型并不需要作为闭包表达式定义的一部分。因为所有的类型都可以被正确推断，返回箭头<code>（-&gt;）</code>和围绕在参数周围的括号也可以被省略：</p><p><code>reversedNames = names.sorted(by: &#123; s1, s2 in return s1 &gt; s2 &#125; ) </code></p><p>实际上，通过内联闭包表达式构造的闭包作为参数传递给函数或方法时，总是能够推断出闭包的参数和返回值类型。这意味着闭包作为函数或者方法的参数时，你几乎不需要利用完整格式构造内联闭包。<br>尽管如此，你仍然可以明确写出有着完整格式的闭包。如果完整格式的闭包能够提高代码的可读性，则我们更鼓励采用完整格式的闭包。而在 sorted(by:) 方法这个例子里，显然闭包的目的就是排序。由于这个闭包是为了处理字符串数组的排序，因此读者能够推测出这个闭包是用于字符串处理的。</p><h2 id="单表达式闭包的隐式返回"><a href="#单表达式闭包的隐式返回" class="headerlink" title="单表达式闭包的隐式返回"></a>单表达式闭包的隐式返回</h2><p>单行表达式闭包可以通过省略<code>return</code> 关键字来隐式返回单行表达式的结果，如上版本的例子可以改写为：<br>复制</p><p><code>reversedNames = names.sorted(by: &#123; s1, s2 in s1 &gt; s2 &#125; )</code></p><p>在这个例子中，<code>sorted(by:)</code> 方法的参数类型明确了闭包必须返回一个 <code>Bool</code> 类型值。因为闭包函数体只包含了一个单一表达式（<code>s1 &gt; s2）</code>，该表达式返回 <code>Bool </code>类型值，因此这里没有歧义，<code>return </code>关键字可以省略。</p><h2 id="参数名称缩写"><a href="#参数名称缩写" class="headerlink" title="参数名称缩写"></a>参数名称缩写</h2><p>Swift 自动为内联闭包提供了参数名称缩写功能，你可以直接通过 <code>$0</code>，<code>$1</code>，<code>$2</code> 来顺序调用闭包的参数，以此类推。</p><p>如果你在闭包表达式中使用参数名称缩写，你可以在闭包定义中省略参数列表，并且对应参数名称缩写的类型会通过函数类型进行推断。闭包接受的参数的数量取决于所使用的缩写参数的最大编号。<code>in</code> 关键字也同样可以被省略，因为此时闭包表达式完全由闭包函数体构成：<br>复制</p><p><code>reversedNames = names.sorted(by: &#123; $0 &gt; $1 &#125; )</code></p><p>在这个例子中，<code>$0</code> 和 <code>$1</code> 表示闭包中第一个和第二个 <code>String</code> 类型的参数。因为 $1 是编号最大的缩写参数，所以可以理解为：该闭包需要两个参数。这里的 <code>sorted(by:) </code>函数希望得到一个参数都是字符串的闭包，因此缩写参数 <code>$0</code> 和 <code>$1</code> 的类型均为 <code>String</code>。</p><h2 id="运算符方法"><a href="#运算符方法" class="headerlink" title="运算符方法"></a>运算符方法</h2><p>实际上还有一种更简短的方式来编写上面例子中的闭包表达式。<code>Swift</code> 的 <code>String</code> 类型定义了关于大于号<code>（&gt;）</code>的字符串实现，其作为一个函数接受两个 <code>String </code>类型的参数并返回 <code>Bool</code> 类型的值。而这正好与 <code>sorted(by:)</code> 方法的参数需要的函数类型相符合。因此，你可以简单地传递一个大于号，<code>Swift </code>可以自动推断找到系统自带的那个字符串函数的实现：</p><p><code>reversedNames = names.sorted(by: &gt;)</code></p><h2 id="尾随闭包"><a href="#尾随闭包" class="headerlink" title="尾随闭包"></a>尾随闭包</h2><p>如果你需要将一个很长的闭包表达式作为最后一个参数传递给函数，将这个闭包替换成为尾随闭包的形式很有用。尾随闭包是一个书写在函数圆括号之后的闭包表达式，函数支持将其作为最后一个参数调用。在使用尾随闭包时，你不用写出它的参数标签：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">func <span class="hljs-title function_">someFunctionThatTakesAClosure</span>(<span class="hljs-params">closure: () -&gt; Void</span>) &#123;<br>    <span class="hljs-comment">// 函数体部分</span><br>&#125;<br><br><span class="hljs-comment">// 以下是不使用尾随闭包进行函数调用</span><br><span class="hljs-title function_">someFunctionThatTakesAClosure</span>(<span class="hljs-attr">closure</span>: &#123;<br>    <span class="hljs-comment">// 闭包主体部分</span><br>&#125;)<br><br><span class="hljs-comment">// 以下是使用尾随闭包进行函数调用</span><br><span class="hljs-title function_">someFunctionThatTakesAClosure</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 闭包主体部分</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 闭包表达式语法 上章节中的字符串排序闭包可以作为尾随包的形式改写在 <code>sorted(by:)</code> 方法圆括号的外面：</p><p><code>reversedNames = names.sorted() &#123; $0 &gt; $1 &#125;</code></p><p>如果闭包表达式是函数或方法的唯一参数，则当你使用尾随闭包时，你甚至可以把 () 省略掉：</p><p><code>reversedNames = names.sorted &#123; $0 &gt; $1 &#125;</code></p><p>当闭包非常长以至于不能在一行中进行书写时，尾随闭包变得非常有用。举例来说，<code>Swift </code>的 <code>Array</code> 类型有一个 <code>map(_:)</code> 方法，这个方法获取一个闭包表达式作为其唯一参数。该闭包函数会为数组中的每一个元素调用一次，并返回该元素所映射的值。具体的映射方式和返回值类型由闭包来指定。<br>当提供给数组的闭包应用于每个数组元素后，<code>map(_:)</code> 方法将返回一个新的数组，数组中包含了与原数组中的元素一一对应的映射后的值。</p><p>下例介绍了如何在 <code>map(_:) </code>方法中使用尾随闭包将 <code>Int</code> 类型数组 <code>[16, 58, 510]</code> 转换为包含对应 <code>String</code> 类型的值的数组 <code>[&quot;OneSix&quot;, &quot;FiveEight&quot;, &quot;FiveOneZero&quot;]：</code></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-keyword">let</span> <span class="hljs-attr">digitNames</span> = [<br>    <span class="hljs-number">0</span>: <span class="hljs-string">&quot;Zero&quot;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&quot;One&quot;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&quot;Two&quot;</span>,   <span class="hljs-number">3</span>: <span class="hljs-string">&quot;Three&quot;</span>, <span class="hljs-number">4</span>: <span class="hljs-string">&quot;Four&quot;</span>,<br>    <span class="hljs-number">5</span>: <span class="hljs-string">&quot;Five&quot;</span>, <span class="hljs-number">6</span>: <span class="hljs-string">&quot;Six&quot;</span>, <span class="hljs-number">7</span>: <span class="hljs-string">&quot;Seven&quot;</span>, <span class="hljs-number">8</span>: <span class="hljs-string">&quot;Eight&quot;</span>, <span class="hljs-number">9</span>: <span class="hljs-string">&quot;Nine&quot;</span><br>]<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">numbers</span> = [<span class="hljs-number">16</span>, <span class="hljs-number">58</span>, <span class="hljs-number">510</span>]<br></code></pre></td></tr></table></figure><p>如上代码创建了一个整型数位和它们英文版本名字相映射的字典。同时还定义了一个准备转换为字符串数组的整型数组。<br>你现在可以通过传递一个尾随闭包给<code> numbers</code> 数组的 <code>map(_:) </code>方法来创建对应的字符串版本数组：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> strings = numbers.<span class="hljs-property">map</span> &#123;<br>    (<span class="hljs-built_in">number</span>) -&gt; <span class="hljs-title class_">String</span> <span class="hljs-keyword">in</span><br>    <span class="hljs-keyword">var</span> <span class="hljs-built_in">number</span> = <span class="hljs-built_in">number</span><br>    <span class="hljs-keyword">var</span> output = <span class="hljs-string">&quot;&quot;</span><br>    repeat &#123;<br>        output = digitNames[<span class="hljs-built_in">number</span> % <span class="hljs-number">10</span>]! + output<br>        <span class="hljs-built_in">number</span> /= <span class="hljs-number">10</span><br>    &#125; <span class="hljs-keyword">while</span> <span class="hljs-built_in">number</span> &gt; <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> output<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F; strings 常量被推断为字符串类型数组，即 [String]<br>&#x2F;&#x2F; 其值为 <code>[&quot;OneSix&quot;, &quot;FiveEight&quot;, &quot;FiveOneZero&quot;]</code><br><code>map(_:)</code> 为数组中每一个元素调用了一次闭包表达式。你不需要指定闭包的输入参数 number 的类型，因为可以通过要映射的数组类型进行推断。</p><p>在该例中，局部变量 <code>number</code> 的值由闭包中的 <code>number</code> 参数获得，因此可以在闭包函数体内对其进行修改，(闭包或者函数的参数总是常量)，闭包表达式指定了返回类型为 <code>String</code>，以表明存储映射值的新数组类型为 <code>String</code>。<br>闭包表达式在每次被调用的时候创建了一个叫做 <code>output</code> 的字符串并返回。其使用求余运算符<code>（number % 10）</code>计算最后一位数字并利用<code>digitNames</code>字典获取所映射的字符串。这个闭包能够用于创建任意正整数的字符串表示。</p><p>注意<br>字典<code>digitNames</code>下标后跟着一个叹号（!），因为字典下标返回一个可选值<code>（optional value）</code>，表明该键不存在时会查找失败。在上例中，由于可以确定 <code>number % 10</code>总是 <code>digitNames </code>字典的有效下标，因此叹号可以用于强制解包<code>（force-unwrap）</code>存储在下标的可选类型的返回值中的 <code>String </code>类型的值。<br>从 <code>digitNames </code>字典中获取的字符串被添加到 <code>output</code> 的前部，逆序建立了一个字符串版本的数字。（<code>在表达式 number % 10 中，如果 number 为 16</code>，则返回 <code>6</code>，<code>58 </code>返回 <code>8</code>，<code>510 </code>返回 <code>0</code>。）<br><code>number</code> 变量之后除以 <code>10</code>。因为其是整数，在计算过程中未除尽部分被忽略。因此 16 变成了 <code>1</code>，<code>58</code> 变成了 <code>5</code>，<code>510</code> 变成了 <code>51</code>。<br>整个过程重复进行，直到 <code>number /= 10 </code>为<code> 0</code>，这时闭包会将字符串 <code>output</code> 返回，而 <code>map(_:)</code> 方法则会将字符串添加到映射数组中。<br>在上面的例子中，通过尾随闭包语法，优雅地在函数后封装了闭包的具体功能，而不再需要将整个闭包包裹在 <code>map(_:)</code> 方法的括号内。<br>如果一个函数接受多个闭包，您需要省略第一个尾随闭包的参数标签，并为其余尾随闭包添加标签。例如，以下函数将为图片库加载一张图片：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript">func loadPicture<span class="hljs-function"><span class="hljs-params">(<span class="hljs-keyword">from</span> server: Server, completion:(Picture) -&gt; Void,</span></span><br><span class="hljs-params"><span class="hljs-function">onFailure: () -&gt; Void)</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">if</span> <span class="hljs-title">let</span> <span class="hljs-title">picture</span> = <span class="hljs-title">download</span><span class="hljs-params">(<span class="hljs-string">&quot;photo.jpg&quot;</span>, <span class="hljs-keyword">from</span>: server)</span>&#123;</span><br><span class="hljs-function"><span class="hljs-title">completion</span><span class="hljs-params">(picture)</span></span><br><span class="hljs-function">&#125;<span class="hljs-title">else</span>&#123;</span><br><span class="hljs-function"><span class="hljs-title">onFailure</span><span class="hljs-params">()</span></span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>当您调用该函数以加载图片时，需要提供两个闭包。第一个闭包是一个完成处理程序，它在成功下载后加载图片；第二个闭包是一个错误处理程序，它向用户显示错误。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">loadPicture</span><span class="hljs-params">(from: someServer)</span></span>&#123;<span class="hljs-selector-tag">picture</span> <span class="hljs-keyword">in</span><br>someView<span class="hljs-selector-class">.currentPicture</span> = <span class="hljs-selector-tag">picture</span><br>&#125; onFailure: &#123;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Couldn&#x27;t download the next picture.&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在本例中，<code>loadPicture(from:completion:onFailure:)</code> 函数将它的网络任务分配到后台，并在网络任务完成时调用两个完成处理程序中的一个。通过这种方法编写函数，您将能够把负责处理网络故障的代码和成功下载后更新用户界面的代码干净地区分开，而不是只使用一个闭包处理两种情况。</p><h2 id="值捕获"><a href="#值捕获" class="headerlink" title="值捕获"></a>值捕获</h2><p>闭包可以在其被定义的上下文中捕获常量或变量。即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。</p><p><code>Swift</code> 中，可以捕获值的闭包的最简单形式是嵌套函数，也就是定义在其他函数的函数体内的函数。嵌套函数可以捕获其外部函数所有的参数以及定义的常量和变量。</p><p>举个例子，这有一个叫做 <code>makeIncrementer</code> 的函数，其包含了一个叫做 <code>incrementer </code>的嵌套函数。嵌套函数 <code>incrementer() </code>从上下文中捕获了两个值，<code>runningTotal </code>和 <code>amount</code>。捕获这些值之后，<code>makeIncrementer</code>将 <code>incrementer </code>作为闭包返回。每次调用 <code>incrementer </code>时，其会以 <code>amount</code> 作为增量增加 <code>runningTotal </code>的值。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript">func makeIncrementer<span class="hljs-function"><span class="hljs-params">(forIncrement amount: Int)</span> -&gt;</span> <span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> Int &#123;<br>    <span class="hljs-keyword">var</span> runningTotal = <span class="hljs-number">0</span><br>    func incrementer<span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> Int &#123;<br>        runningTotal += amount<br>        <span class="hljs-keyword">return</span> runningTotal<br>    &#125;<br>    <span class="hljs-keyword">return</span> incrementer<br>&#125;<br></code></pre></td></tr></table></figure><p><code>makeIncrementer</code> 返回类型为 <code>() -&gt; Int</code>。这意味着其返回的是一个函数，而非一个简单类型的值。该函数在每次调用时不接受参数，只返回一个 <code>Int </code>类型的值。关于函数返回其他函数的内容，请查看 函数类型作为返回类型。<br><code>makeIncrementer(forIncrement:)</code> 函数定义了一个初始值为<code>0</code>的整型变量 <code>runningTotal</code>，用来存储当前总计数值。该值为<code>incrementer</code>的返回值。<br><code>makeIncrementer(forIncrement:) </code>有一个 <code>Int</code> 类型的参数，其外部参数名为 <code>forIncrement</code>，内部参数名为 <code>amount</code>，该参数表示每次 <code>incrementer </code>被调用时<code>runningTotal</code>将要增加的量。<code>makeIncrementer </code>函数还定义了一个嵌套函数<code> incrementer</code>，用来执行实际的增加操作。该函数简单地使<code>runningTotal</code>增加 <code>amount</code>，并将其返回。<br>如果我们单独考虑嵌套函数 <code>incrementer()</code>，会发现它有些不同寻常：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript">func incrementer<span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> Int &#123;<br>    runningTotal += amount<br>    <span class="hljs-keyword">return</span> runningTotal<br>&#125;<br></code></pre></td></tr></table></figure><p><code>incrementer()</code> 函数并没有任何参数，但是在函数体内访问了 <code>runningTotal</code> 和 <code>amount</code> 变量。这是因为它从外围函数捕获了<code> runningTotal</code> 和 <code>amount </code>变量的引用。捕获引用保证了<code> runningTotal</code> 和 <code>amount</code> 变量在调用完 <code>makeIncrementer </code>后不会消失，并且保证了在下一次执行 <code>incrementer </code>函数时，<code>runningTotal </code>依旧存在。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">注意<br>为了优化，如果一个值不会被闭包改变，或者在闭包创建后不会改变，<span class="hljs-keyword">Swift </span>可能会改为捕获并保存一份对值的拷贝。<br><span class="hljs-keyword">Swift </span>也会负责被捕获变量的所有内存管理工作，包括释放不再需要的变量。<br></code></pre></td></tr></table></figure><p>下面是一个使用<code> makeIncrementer</code> 的例子：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">let</span> <span class="hljs-variable">incrementByTen</span> = <span class="hljs-function"><span class="hljs-title">makeIncrementer</span>(<span class="hljs-variable">forIncrement</span>: <span class="hljs-number">10</span>)</span><br></code></pre></td></tr></table></figure><p>该例子定义了一个叫做 <code>incrementByTen </code>的常量，该常量指向一个每次调用会将其 <code>runningTotal</code> 变量增加 <code>10 </code>的 <code>incrementer</code> 函数。调用这个函数多次可以得到以下结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">incrementByTen</span><span class="hljs-params">()</span></span><br><span class="hljs-comment">// 返回的值为10</span><br><span class="hljs-function"><span class="hljs-title">incrementByTen</span><span class="hljs-params">()</span></span><br><span class="hljs-comment">// 返回的值为20</span><br><span class="hljs-function"><span class="hljs-title">incrementByTen</span><span class="hljs-params">()</span></span><br><span class="hljs-comment">// 返回的值为30</span><br></code></pre></td></tr></table></figure><p>如果你创建了另一个 <code>incrementer</code>，它会有属于自己的引用，指向一个全新、独立的 <code>runningTotal</code> 变量：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">let</span> <span class="hljs-variable">incrementBySeven</span> = <span class="hljs-function"><span class="hljs-title">makeIncrementer</span>(<span class="hljs-variable">forIncrement</span>: <span class="hljs-number">7</span>)</span><br><span class="hljs-function"><span class="hljs-title">incrementBySeven</span>()</span><br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F; 返回的值为7<br>再次调用原来的 <code>incrementByTen </code>会继续增加它自己的<code> runningTotal</code> 变量，该变量和<code>incrementBySeven</code>中捕获的变量没有任何联系：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">incrementByTen</span><span class="hljs-params">()</span></span><br><span class="hljs-comment">// 返回的值为40</span><br></code></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">注意<br>如果你将闭包赋值给一个类实例的属性，并且该闭包通过访问该实例或其成员而捕获了该实例，你将在闭包和该实例间创建一个循环强引用。<span class="hljs-keyword">Swift </span>使用捕获列表来打破这种循环强引用。更多信息，请参考 闭包引起的循环强引用。<br></code></pre></td></tr></table></figure><h2 id="闭包是引用类型"><a href="#闭包是引用类型" class="headerlink" title="闭包是引用类型"></a>闭包是引用类型</h2><p>上面的例子中，<code>incrementBySeven </code>和 <code>incrementByTen </code>都是常量，但是这些常量指向的闭包仍然可以增加其捕获的变量的值。这是因为函数和闭包都是引用类型。<br>无论你将函数或闭包赋值给一个常量还是变量，你实际上都是将常量或变量的值设置为对应函数或闭包的引用。上面的例子中，指向闭包的引用 <code>incrementByTen </code>是一个常量，而并非闭包内容本身。<br>这也意味着如果你将闭包赋值给了两个不同的常量或变量，两个值都会指向同一个闭包：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">let alsoIncrementByTen = incrementByTen<br><span class="hljs-function"><span class="hljs-title">alsoIncrementByTen</span><span class="hljs-params">()</span></span><br><span class="hljs-comment">// 返回的值为50</span><br></code></pre></td></tr></table></figure><h2 id="逃逸闭包"><a href="#逃逸闭包" class="headerlink" title="逃逸闭包"></a>逃逸闭包</h2><p>当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行，我们称该闭包从函数中逃逸。当你定义接受闭包作为参数的函数时，你可以在参数名之前标注 @escaping，用来指明这个闭包是允许“逃逸”出这个函数的。<br>一种能使闭包“逃逸”出函数的方法是，将这个闭包保存在一个函数外部定义的变量中。举个例子，很多启动异步操作的函数接受一个闭包参数作为 <code>completion handler</code>。这类函数会在异步操作开始之后立刻返回，但是闭包直到异步操作结束后才会被调用。在这种情况下，闭包需要“逃逸”出函数，因为闭包需要在函数返回之后被调用。例如：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">var</span> completionHandlers: [<span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> Void] = []<br>func someFunctionWithEscapingClosure<span class="hljs-function"><span class="hljs-params">(completionHandler: @escaping () -&gt; Void)</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">completionHandlers</span>.<span class="hljs-title">append</span><span class="hljs-params">(completionHandler)</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p><code>someFunctionWithEscapingClosure(_:)</code> 函数接受一个闭包作为参数，该闭包被添加到一个函数外定义的数组中。如果你不将这个参数标记为<code> @escaping</code>，就会得到一个编译错误。<br>将一个闭包标记为 <code>@escaping</code> 意味着你必须在闭包中显式地引用 self。比如说，在下面的代码中，传递到 <code>someFunctionWithEscapingClosure(_:)</code> 中的闭包是一个逃逸闭包，这意味着它需要显式地引用 <code>self</code>。相对的，传递到 <code>someFunctionWithNonescapingClosure(_:) </code>中的闭包是一个非逃逸闭包，这意味着它可以隐式引用 <code>self</code>。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs livescript">func someFunctionWithNonescapingClosure<span class="hljs-function"><span class="hljs-params">(closure: () -&gt; Void)</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">closure</span><span class="hljs-params">()</span></span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">SomeClass</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">var</span> <span class="hljs-title">x</span> = 10</span><br><span class="hljs-function">    <span class="hljs-title">func</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> &#123;</span><br><span class="hljs-function">        <span class="hljs-title">someFunctionWithEscapingClosure</span> &#123; <span class="hljs-title">self</span>.<span class="hljs-title">x</span> = 100 &#125;</span><br><span class="hljs-function">        <span class="hljs-title">someFunctionWithNonescapingClosure</span> &#123; <span class="hljs-title">x</span> = 200 &#125;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">let</span> <span class="hljs-title">instance</span> = <span class="hljs-title">SomeClass</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">instance</span>.<span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(instance.x)</span></span><br><span class="hljs-function">// 打印出“200”</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">completionHandlers</span>.<span class="hljs-title">first</span>?<span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(instance.x)</span></span><br><span class="hljs-function">// 打印出“100”</span><br></code></pre></td></tr></table></figure><h2 id="自动闭包"><a href="#自动闭包" class="headerlink" title="自动闭包"></a>自动闭包</h2><p>自动闭包是一种自动创建的闭包，用于包装传递给函数作为参数的表达式。这种闭包不接受任何参数，当它被调用的时候，会返回被包装在其中的表达式的值。这种便利语法让你能够省略闭包的花括号，用一个普通的表达式来代替显式的闭包。</p><p>我们经常会调用采用自动闭包的函数，但是很少去实现这样的函数。举个例子来说，<code>assert(condition:message:file:line:)</code> 函数接受自动闭包作为它的 <code>condition</code> 参数和 <code>message</code> 参数；它的 <code>condition</code> 参数仅会在 debug 模式下被求值，它的 <code>message</code> 参数仅当 <code>condition </code>参数为 <code>false </code>时被计算求值。<br>自动闭包让你能够延迟求值，因为直到你调用这个闭包，代码段才会被执行。延迟求值对于那些有副作用（Side Effect）和高计算成本的代码来说是很有益处的，因为它使得你能控制代码的执行时机。下面的代码展示了闭包如何延时求值。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> customersInLine = <span class="hljs-selector-attr">[<span class="hljs-string">&quot;Chris&quot;</span>, <span class="hljs-string">&quot;Alex&quot;</span>, <span class="hljs-string">&quot;Ewa&quot;</span>, <span class="hljs-string">&quot;Barry&quot;</span>, <span class="hljs-string">&quot;Daniella&quot;</span>]</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(customersInLine.count)</span></span><br><span class="hljs-comment">// 打印出“5”</span><br><br>let customerProvider = &#123; customersInLine<span class="hljs-selector-class">.remove</span>(at: <span class="hljs-number">0</span>) &#125;<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(customersInLine.count)</span></span><br><span class="hljs-comment">// 打印出“5”</span><br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">&quot;Now serving \(customerProvider())!&quot;</span>)</span></span><br><span class="hljs-comment">// 打印出“Now serving Chris!”</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(customersInLine.count)</span></span><br><span class="hljs-comment">// 打印出“4”</span><br></code></pre></td></tr></table></figure><p>尽管在闭包的代码中，<code>customersInLine</code> 的第一个元素被移除了，不过在闭包被调用之前，这个元素是不会被移除的。如果这个闭包永远不被调用，那么在闭包里面的表达式将永远不会执行，那意味着列表中的元素永远不会被移除。请注意，<code>customerProvider</code> 的类型不是 <code>String</code>，而是<code> () -&gt; String</code>，一个没有参数且返回值为 <code>String</code> 的函数。<br>将闭包作为参数传递给函数时，你能获得同样的延时求值行为。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span> customersInLine <span class="hljs-keyword">is</span> [<span class="hljs-string">&quot;Alex&quot;</span>, <span class="hljs-string">&quot;Ewa&quot;</span>, <span class="hljs-string">&quot;Barry&quot;</span>, <span class="hljs-string">&quot;Daniella&quot;</span>]<br>func serve(customer customerProvider: <span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> <span class="hljs-built_in">String</span>) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Now serving \(customerProvider())!&quot;</span>)<br>&#125;<br>serve(customer: &#123; customersInLine.remove(at: <span class="hljs-number">0</span>) &#125; )<br><span class="hljs-regexp">//</span> 打印出“Now serving Alex!”<br></code></pre></td></tr></table></figure><p>上面的 <code>serve(customer:) </code>函数接受一个返回顾客名字的显式的闭包。下面这个版本的 <code>serve(customer:)</code> 完成了相同的操作，不过它并没有接受一个显式的闭包，而是通过将参数标记为 <code>@autoclosure </code>来接收一个自动闭包。现在你可以将该函数当作接受 <code>String</code> 类型参数（而非闭包）的函数来调用。<code>customerProvider </code>参数将自动转化为一个闭包，因为该参数被标记了 <code>@autoclosure</code> 特性。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// customersInLine is [&quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]</span><br><span class="hljs-selector-tag">func</span> <span class="hljs-selector-tag">serve</span>(customer <span class="hljs-attribute">customerProvider</span>: <span class="hljs-variable">@autoclosure</span> () -&gt; String) &#123;<br>    <span class="hljs-selector-tag">print</span>(<span class="hljs-string">&quot;Now serving \(customerProvider())!&quot;</span>)<br>&#125;<br><span class="hljs-selector-tag">serve</span>(<span class="hljs-attribute">customer</span>: customersInLine.<span class="hljs-built_in">remove</span>(<span class="hljs-attribute">at</span>: <span class="hljs-number">0</span>))<br><span class="hljs-comment">// 打印“Now serving Ewa!”</span><br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">注意<br>过度使用 <span class="hljs-built_in">auto</span>closures 会让你的代码变得难以理解。上下文和函数名应该能够清晰地表明求值是被延迟执行的。<br></code></pre></td></tr></table></figure><p>如果你想让一个自动闭包可以“逃逸”，则应该同时使用 <code>@autoclosure</code> 和<code> @escaping</code> 属性。<code>@escaping </code>属性的讲解见上面的 逃逸闭包。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><br><span class="hljs-comment">// customersInLine i= [&quot;Barry&quot;, &quot;Daniella&quot;]</span><br><span class="hljs-selector-tag">var</span> customerProviders: <span class="hljs-selector-attr">[() -&gt; String]</span> = <span class="hljs-selector-attr">[]</span><br>func <span class="hljs-built_in">collectCustomerProviders</span>(_ customerProvider: @autoclosure @escaping () -&gt; String) &#123;<br>    customerProviders<span class="hljs-selector-class">.append</span>(customerProvider)<br>&#125;<br><span class="hljs-function"><span class="hljs-title">collectCustomerProviders</span><span class="hljs-params">(customersInLine.remove(at: <span class="hljs-number">0</span>)</span></span>)<br><span class="hljs-function"><span class="hljs-title">collectCustomerProviders</span><span class="hljs-params">(customersInLine.remove(at: <span class="hljs-number">0</span>)</span></span>)<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">&quot;Collected \(customerProviders.count) closures.&quot;</span>)</span></span><br><span class="hljs-comment">// 打印“Collected 2 closures.”</span><br><span class="hljs-keyword">for</span> customerProvider <span class="hljs-keyword">in</span> customerProviders &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Now serving \(customerProvider())!&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 打印“Now serving Barry!”</span><br><span class="hljs-comment">// 打印“Now serving Daniella!”</span><br></code></pre></td></tr></table></figure><p>在上面的代码中，<code>collectCustomerProviders(_:) </code>函数并没有调用传入的<code> customerProvider</code> 闭包，而是将闭包追加到了 <code>customerProviders</code> 数组中。这个数组定义在函数作用域范围外，这意味着数组内的闭包能够在函数返回之后被调用。因此，<code>customerProvider </code>参数必须允许“逃逸”出函数作用域。</p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>八股文-Closures</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS-Libiary</title>
    <link href="/myblog/2024/10/29/iOS-Libiary/"/>
    <url>/myblog/2024/10/29/iOS-Libiary/</url>
    
    <content type="html"><![CDATA[<h1 id="iOS资源"><a href="#iOS资源" class="headerlink" title="iOS资源"></a>iOS资源</h1><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li><a href="#getting-started">入门</a></li><li><a href="#libraries-and-frameworks">库和框架</a><ul><li><a href="#audio">音频</a></li><li><a href="#animation">动画</a></li><li><a href="#apple-tv">Apple TV</a></li><li><a href="#bridging">桥接</a></li><li><a href="#cache">缓存</a></li><li><a href="#core-data">Core Data</a></li><li><a href="#charts">图表</a></li><li><a href="#database">数据库</a></li><li><a href="#hardware">硬件</a><ul><li><a href="#motion">动作</a></li><li><a href="#bluetooth">蓝牙</a></li><li><a href="#location">位置</a></li><li><a href="#ibeacon">iBeacon</a></li></ul></li><li><a href="#hud">HUD</a></li><li><a href="#eventbus">事件总线（ EventBus ）</a></li><li><a href="#files">文件</a></li><li><a href="#json">JSON</a></li><li><a href="#layout">布局</a></li><li><a href="#logging">日志</a></li><li><a href="#maps">地图</a></li><li><a href="#media">媒体</a><ul><li><a href="#image">图片</a></li><li><a href="#video">视频</a></li><li><a href="#pdf">PDF</a></li></ul></li><li><a href="#messaging">消息</a></li><li><a href="#networking">网络</a></li><li><a href="#push-notifications">推送通知</a></li><li><a href="#passbook">Passbook</a></li><li><a href="#permissions">权限</a></li><li><a href="#text">文本</a></li><li><a href="#walkthrough--intro--tutorial">浏览 &#x2F; 介绍 &#x2F; 教程</a></li><li><a href="#url-scheme">URL Scheme</a></li><li><a href="#ui">UI</a></li><li><a href="#websocket">Websocket</a></li><li><a href="#code-quality">代码质量</a></li><li><a href="#analytics">分析</a></li><li><a href="#payments">支付</a></li><li><a href="#products">产品化工具</a></li><li><a href="#utility">实用工具</a></li><li><a href="#security">安全</a></li></ul></li><li><a href="#project-setup">安装项目</a></li><li><a href="#dependency--package-manager">依赖 &#x2F; 包管理</a></li><li><a href="#testing">测试</a><ul><li><a href="#tdd--bdd">测试驱动开发（TDD） &#x2F; 行为驱动开发（BDD）</a></li><li><a href="#ui-testing">UI测试</a></li><li><a href="#beta-distribution">Beta 测试</a></li><li><a href="#other-testing">其他测试</a></li></ul></li><li><a href="#toolchains">工具链</a></li><li><a href="#tools">工具</a></li><li><a href="#rapid-development">敏捷开发</a></li><li><a href="#deployment">部署</a></li><li><a href="#app-store">App Store</a></li><li><a href="#sdk">SDK</a></li><li><a href="#xcode">Xcode</a><ul><li><a href="#plugins">插件</a></li><li><a href="#themes">主题</a></li><li><a href="#other-xcode">其他 Xcode 相关</a></li></ul></li><li><a href="#style-guides" title="编码规范">编码规范</a></li><li><a href="#good-websites">一些好网站</a><ul><li><a href="#news-blogs-and-more">新闻, 博客等</a></li><li><a href="#uikit-references">UIKIt 文档</a></li><li><a href="#forums-and-discuss-lists">论坛和讨论列表</a></li><li><a href="#tutorials-and-keynotes">教程和 Keynotes</a></li><li><a href="#prototyping">原型</a></li></ul></li><li><a href="#twitter">Twitter</a></li><li><a href="#facebook-groups">Facebook 群组</a></li><li><a href="#podcasts">播客（Podcasts）</a></li><li><a href="#books">书籍</a></li><li><a href="#other-awesome-lists">其他优秀的列表</a></li><li><a href="#resources">资源</a></li></ul><h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a><a name="getting-started"></a>入门</h1><ul><li>Road Map iOS：开发 iOS 应用从今天开始，苹果指南。★<a href="https://developer.apple.com/library/prerelease/ios/referencelibrary/GettingStarted/DevelopiOSAppsSwift/">官网</a></li><li>Lifehacker：我想写一个 iOS 应用，该从哪里开始？<a href="http://lifehacker.com/i-want-to-write-ios-apps-where-do-i-start-1644802175">官网</a></li><li>Codeproject：入门 iPhone 和 iOS 应用开发。<a href="http://www.codeproject.com/Articles/88929/Getting-Started-with-iPhone-and-iOS-Development">官网</a></li><li>Ray Wenderlich：学习 iOS 应用开发。<a href="http://www.raywenderlich.com/38557/learn-to-code-ios-apps-1-welcome-to-programming">官网</a></li><li>Stanford：Developing Apps to iOS：斯坦福在 iTunes U 上的 iOS App 开发课程（音频和视频）。<a href="https://itunes.apple.com/us/itunes-u/developing-apps-for-ios-hd/id395605774?mt=10">官网</a></li><li>Stanford：Developing iOS 8 Apps with Swift：斯坦福在 iTunes U 上用 Swift 开发 App 的课程（2015版）。★<a href="https://itunes.apple.com/us/course/developing-ios-8-apps-swift/id961180099">官网</a></li></ul><h1 id="库和框架"><a href="#库和框架" class="headerlink" title="库和框架"></a><a name="libraries-and-frameworks"></a>库和框架</h1><h3 id="音频"><a href="#音频" class="headerlink" title="音频"></a><a name="audio"></a>音频</h3><ul><li><a href="http://hao.importnew.com/audiobu/">AudioBus</a>：下一代 App 到 App 的实时音频路由。<a href="https://developer.audiob.us/">官网</a></li><li><a href="http://hao.importnew.com/audiokit/">AudioKit</a>：一个强大的音频合成，处理和分析的工具集。<a href="https://github.com/audiokit/AudioKit">官网</a></li><li><a href="http://hao.importnew.com/ezaudio/">EZAudio</a>：一个基于 Core Audio 的 iOS&#x2F;OSX 音频可视化框架。用于实时，低延迟的音频处理和可视化功能的开发。<a href="https://github.com/syedhali/EZAudio">官网</a></li><li><a href="http://hao.importnew.com/theamazingaudioengine/">TheAmazingAudioEngine</a>：是iOS音频处理框架，简单易用，能对音频进行处理。<a href="https://github.com/TheAmazingAudioEngine/TheAmazingAudioEngine">官网</a></li><li><a href="http://hao.importnew.com/novocaine/">novocaine</a>：应用于 OSX 和 iOS 的高性能音频框架。<a href="https://github.com/alexbw/novocaine">官网</a> </li><li><a href="http://hao.importnew.com/qhspeechsynthesizerqueue/">QHSpeechSynthesizerQueue</a>：一个 <code>AVSpeechSynthesizer</code>（iOS文本发音） 的队列管理系统。<a href="https://github.com/quentinhayot/QHSpeechSynthesizerQueue">官网</a></li><li><a href="http://hao.importnew.com/streamingkit/">StreamingKit</a>：一个针对 OSX 和 iOS 中 <code>AudioPlayer/AudioStreamer</code> 快捷的无缝扩展。<a href="https://github.com/tumtumtum/StreamingKit">官网</a></li><li><a href="http://hao.importnew.com/sound-fader-ios/">sound-fader-ios</a>：一个 Swift 写的 <code>AVAudioPlayer</code> 的声音控制器 <a href="https://github.com/evgenyneu/sound-fader-ios">官网</a>★</li></ul><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><ul><li><a href="http://hao.importnew.com/pop/">Pop</a>：一个 iOS 和 OS X 动画库，可以方便地实现由物理效果的交互。<a href="https://github.com/facebook/pop">官网</a> </li><li><a href="http://hao.importnew.com/animationengine/">AnimationEngine</a>：可以在 iOS 上方便地构建高级自定义动画。<a href="https://github.com/intuit/AnimationEngine">官网</a></li><li><a href="http://hao.importnew.com/awesome-ios-animation/">Awesome-iOS-Animation</a>：一个动画项目的集合。<a href="https://github.com/jackyzh/awesome-ios-animation">官网</a></li><li><a href="http://hao.importnew.com/rztransitions/">RZTransitions</a>：iOS View Controller 过场动画库。<a href="https://github.com/Raizlabs/RZTransitions">官网</a></li><li><a href="http://hao.importnew.com/dcanimationkit/">DCAnimationKit</a>：iOS 动画集合。很简单，只需要添加流水动画。<a href="https://github.com/daltoniam/DCAnimationKit">官网</a></li><li><a href="http://hao.importnew.com/spring_ios/">Spring</a>：一个简单的 Swift iOS 动画库。<a href="https://github.com/MengTo/Spring">官网</a></li><li><a href="http://hao.importnew.com/canvas/">Canvas</a>：无需代码就可以在 Xcode 中显示动画 <a href="http://canvaspod.io/">http://canvaspod.io</a>。<a href="https://github.com/CanvasPod/Canvas">官网</a></li><li><a href="http://hao.importnew.com/fluent/">Fluent</a>：便捷的 Swift 动画框架。 ★<a href="https://github.com/matthewcheok/Fluent">官网</a></li><li><a href="http://hao.importnew.com/cheetah/">Cheetah</a>：便捷的 iOS 动画库，由 Swift2 编写。 ★<a href="https://github.com/suguru/Cheetah">官网</a></li><li><a href="http://hao.importnew.com/radiallayer/">RadialLayer</a>：针对可点击元素的动画（类似于 Youtube Music）★<a href="https://github.com/soheil/RadialLayer">官网</a></li></ul><h3 id="Apple-TV"><a href="#Apple-TV" class="headerlink" title="Apple TV"></a><a name="apple-tv"></a>Apple TV</h3><ul><li><a href="http://hao.importnew.com/voucher/">Voucher</a>：方便 tvOS App 通过 iOS 设备上相应的程序来认证的库。<a href="https://github.com/rsattar/Voucher">官网</a></li></ul><h3 id="桥接"><a href="#桥接" class="headerlink" title="桥接"></a><a name="bridging"></a>桥接</h3><ul><li><a href="http://hao.importnew.com/jspatch/">JSPatch</a>：JSPatch 利用 Objective-C 运行时桥接了 Objective-C 和 Javascript。你仅需引入一个小的引擎，就可以使用 JS 调用任何 Objective-C 的类。JSPatch 通常用来对 iOS App 做热修复（hotfix）。<a href="https://github.com/bang590/JSPatch">官网</a></li></ul><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a><a name="cache"></a>缓存</h3><ul><li><a href="http://hao.importnew.com/sdurlcache/">SDURLCache</a>：URLCache的子类，可以为 iPhone&#x2F;iPad 应用提供的本地磁盘缓存。<a href="https://github.com/steipete/SDURLCache">官网</a></li><li><a href="http://hao.importnew.com/awesome-cache/">Awesome Cache</a>：让人喜爱的本地缓存 ★<a href="https://github.com/aschuch/AwesomeCache">官网</a> </li><li><a href="http://hao.importnew.com/mattress/">mattress</a>：iOS Web 内容的离线缓存 ★<a href="https://github.com/buzzfeed/mattress">官网</a></li><li><a href="http://hao.importnew.com/carlos/">Carlos</a>：简单但却灵活的缓存 ★<a href="https://github.com/WeltN24/Carlos">官网</a></li></ul><h3 id="图表"><a href="#图表" class="headerlink" title="图表"></a><a name="charts"></a>图表</h3><ul><li><a href="http://hao.importnew.com/ios-charts/">ios-charts</a>：一个强大的图表框架，<a href="https://github.com/PhilJay/MPAndroidChart">MPAndroidChart</a> 在 iOS 上的移植。★<a href="https://github.com/danielgindi/ios-charts">官网</a></li><li><a href="http://hao.importnew.com/jtchartview/">JTChartView</a>：JTChartView 是一个完全可定制的轻量级图表解决方案。<a href="https://github.com/kubatru/JTChartView">官网</a></li><li><a href="http://hao.importnew.com/pnchart/">PNChart</a>：一个简单漂亮的图表库，Pinner 和 CoinsMan 的iOS客户端中使用了这个框架。<a href="https://github.com/kevinzhow/PNChart">官网</a></li><li><a href="http://hao.importnew.com/bemsimplelinegraph/">BEMSimpleLineGraph</a>：优雅的折线图框架。<a href="https://github.com/Boris-Em/BEMSimpleLineGraph">官网</a></li><li><a href="http://hao.importnew.com/jbchartview/">JBChartView</a>：基于 iOS 的图表库，包含折线图和直方图。<a href="https://github.com/Jawbone/JBChartView">官网</a></li><li><a href="http://hao.importnew.com/xypiechart/">XYPieChart</a>：一个有动画的饼图框架。<a href="https://github.com/xyfeng/XYPieChart">官网</a></li><li><a href="http://hao.importnew.com/teachart/">TEAChart</a>：简单易用的 iOS 图表库。包括了贡献图、时钟图、直方图。<a href="https://github.com/xhacker/TEAChart">官网</a></li><li><a href="http://hao.importnew.com/ios-echart/">EChart</a>：iOS&#x2F;iPhone&#x2F;iPad 图表。提供了事件处理和动画支持。<a href="https://github.com/zhuhuihuihui/EChart">官网</a></li><li><a href="http://hao.importnew.com/fslinechart/">FSLineChart</a>：一个 iOS 折线图库。<a href="https://github.com/ArthurGuibert/FSLineChart">官网</a></li><li>chartee：一个为移动平台设计的图表库。<a href="https://github.com/zhiyu/chartee">官网</a></li><li><a href="http://hao.importnew.com/andlinechartview/">ANDLineChartView</a>：使用 ANDLineChartView 可以便捷的在视图类中显示有动画效果的折线图。<a href="https://github.com/anaglik/ANDLineChartView">官网</a></li><li><a href="http://hao.importnew.com/twrcharts/">TWRCharts</a>：一个 ChartJS 的 iOS 封装。结合 Obj-C 原生代码便捷地构建有动画的图表。<a href="https://github.com/chasseurmic/TWRCharts">官网</a></li></ul><h3 id="Core-Data"><a href="#Core-Data" class="headerlink" title="Core Data"></a><a name="core-data"></a>Core Data</h3><ul><li>CWCoreData：方便并发环境下 CoreData 框架开发的扩展与实用工具。<a href="https://github.com/jayway/CWCoreData">官网</a></li><li><a href="http://hao.importnew.com/objectiverecord/">ObjectiveRecord</a>：ActiveRecord 的 Objective-C 版本。<a href="https://github.com/supermarin/ObjectiveRecord">官网</a></li><li><a href="http://hao.importnew.com/ssdatakit/">SSDataKit</a>：消除使用 CoreData 产生的样板代码。<a href="https://github.com/soffes/SSDataKit">官网</a></li><li>ios-queryable：ios-queryable 是一个基于 CoreData 的 IQueryable&#x2F;IEnumerable 实现。<a href="https://github.com/martydill/ios-queryable">官网</a></li><li>ReactiveCoreData：ReactiveCoreData (RCD) 是一个将 CoreData 带入 ReactiveCocoa 世界的尝试。<a href="https://github.com/apparentsoft/ReactiveCoreData">官网</a></li><li><a href="http://hao.importnew.com/ensembles/">Ensembles</a>：一个 CoreData 同步框架。<a href="https://github.com/drewmccormack/ensembles">官网</a></li><li>SLRESTfulCoreData：根据 Objc 命名习惯，在运行时自动生成访问器，URL替换和智能属性映射。<a href="https://github.com/OliverLetterer/SLRESTfulCoreData">官网</a></li><li>Mogenerator：自动生成 CoreData 代码。<a href="https://github.com/rentzsch/mogenerator">官网</a></li><li><a href="http://hao.importnew.com/hardcoredata/">HardCoreData</a>：不会阻塞 UI 线程的 CoreData 栈和控制器。<a href="https://github.com/Krivoblotsky/HardCoreData">官网</a></li><li><a href="http://hao.importnew.com/encrypted-core-data/">encrypted-core-data</a>：使用 SQLClipher 对 CoreData 的 SQLite 存储进行加密。<a href="https://github.com/project-imas/encrypted-core-data">官网</a></li><li><a href="http://hao.importnew.com/magicalrecord/">MagicalRecord</a>：非常优秀的 CoreData 便捷存取框架。<a href="https://github.com/magicalpanda/MagicalRecord">官网</a></li><li>QueryKit：一个简洁的类型安全的 CoreData 查询语言 ★<a href="https://github.com/QueryKit/QueryKit">官网</a></li><li><a href="http://hao.importnew.com/corestore/">CoreStore</a>：强大的 CoreData 框架，解决了增量迁移、获取、观察等问题。★<a href="https://github.com/JohnEstropia/CoreStore">官网</a></li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><a name="database"></a>数据库</h3><ul><li>Realm：CoreData 和 SQLite 的替代品。简洁、现代、快速。<a href="https://github.com/realm/realm-cocoa">官网</a></li><li>YapDatabase：YapDatabase 是一个 iOS 和 Mac 上可扩展的数据库。<a href="https://github.com/yapstudios/YapDatabase">官网</a></li><li>Couchbase Mobile：Couchbase，有云同步支持的移动平台上的文档存储。<a href="http://developer.couchbase.com/mobile/">官网</a></li><li>FMDB：SQLite 的 Cocoa&#x2F;Objective-C 封装。<a href="https://github.com/ccgus/fmdb">官网</a></li><li>Akaibu-NSUserDefaults：Swift 键&#x2F;值存储，只需要一行代码就可以对 NSObject 对象进行归档。类的属性会自动映射和归档。<a href="https://github.com/roytang121/Akaibu-NSUserDefaults">官网</a></li><li>FCModel：为那些喜欢直接使用 SQL 进行数据库操作的人提供的 CoreData 的替代品。<a href="https://github.com/marcoarment/FCModel">官网</a></li><li>Zephyr：轻松地通过 iCloud 同步 NSUserDefaults ★<a href="https://github.com/ArtSabintsev/Zephyr">官网</a></li><li>Prephirences：Prephirences 是一个提供了有用的协议和便捷的方法来管理应用的偏好设置，配置和应用状态的 Swift 库。★<a href="https://github.com/phimage/Prephirences">官网</a></li></ul><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><ul><li>AESCrypt-ObjC：一个简单固执的 AES 加密／解密类，然而它就是可以很好的工作。<a href="https://github.com/Gurpartap/AESCrypt-ObjC">官网</a></li></ul><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a><a name="hardware"></a>硬件</h3><h5 id="动作"><a href="#动作" class="headerlink" title="动作"></a><a name="motion"></a>动作</h5><ul><li><a href="http://hao.importnew.com/motionkit/">MotionKit</a>：只需要两行或者很少的几行代码就可以从加速度传感器、陀螺仪和磁力传感器获取数据。现在 CoreMotion 让这些变得前所未有的简单。<a href="https://github.com/MHaroonBaig/MotionKit">官网</a></li></ul><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a><a name="bluetooth"></a>蓝牙</h5><ul><li>Discovery：这是个很简单的库，用来从附近的设备上发现和获取数据（即便 peer app 在后台工作）。<a href="https://github.com/omergul123/Discovery">官网</a></li><li><a href="http://hao.importnew.com/lgbluetooth/">LGBluetooth</a>：基于 CoreBluetooth 的一个轻量级库，基于 block 制作。它能够让你程序中的 CoreBluetooth 相关的代码更加简洁。<a href="https://github.com/l0gg3r/LGBluetooth">官网</a></li><li>PeerKit：一个用于事件驱动，零配置的 Multipeer 连接应用程序的开源 Swift 框架。★<a href="https://github.com/jpsim/PeerKit">官网</a></li><li>simple-share：一个基于蓝牙 LE 共享的框架，易于实现附近设备的连接。<a href="https://github.com/lauraskelton/simple-share">官网</a></li><li><a href="http://hao.importnew.com/bluetoothkit/">BluetoothKit</a>：使用 BLE 在 iOS&#x2F;OSX 设备之间通讯的框架★<a href="https://github.com/rasmusth/BluetoothKit">官网</a></li></ul><h5 id="位置"><a href="#位置" class="headerlink" title="位置"></a><a name="location"></a>位置</h5><ul><li><a href="http://hao.importnew.com/ingeosdk/">IngeoSDK</a>：总是处于开启状态的 iOS 位置显示框架。<a href="https://github.com/IngeoSDK/ingeo-ios-sdk">官网</a></li><li><a href="http://hao.importnew.com/proxitee/">Proxitee</a>：允许开发者利用 iBeacons 和地理围栏创建近场感知的应用。<a href="https://github.com/Proxitee/iOS-SDK">官网</a></li><li>LocationManager：实现了一次性或者持续请求当前位置的功能，提供了基于 block 的异步 API。<a href="https://github.com/intuit/LocationManager">官网</a></li><li><a href="http://hao.importnew.com/locationkit/">LocationKit</a>：高级位置 SDK － 只使用很少的电量和上下文相关的位置信息就可以提供高精确度的位置数据。<a href="https://locationkit.io/">官网</a></li></ul><h5 id="iBeacon"><a href="#iBeacon" class="headerlink" title="iBeacon"></a><a name="ibeacon"></a>iBeacon</h5><ul><li>Proxitee：允许开发者利用 iBeacons 和地理围栏创建近场感知的应用。<a href="https://github.com/Proxitee/iOS-SDK">官网</a></li><li><a href="http://hao.importnew.com/owuproximitymanager/">OWUProximityManager</a>：一个方便的 iBeacon + CoreBluetooth 管理器。<a href="https://github.com/ohwutup/OWUProximityManager">官网</a></li><li><a href="http://hao.importnew.com/vicinity/">Vicinity</a>：复制邻近的 iBeacons （通过分析RSSI），并支持在后台广播和检测 BLE 设备。<a href="https://github.com/Instrument/Vicinity">官网</a></li><li>BeaconEmitter：把你的 Mac 变成一个 iBeacon。<a href="https://github.com/lgaches/BeaconEmitter">官网</a></li><li>OWUProximityManager：iBeacons + CoreBluetooth.<a href="https://github.com/ohwutup/OWUProximityManager">官网</a></li></ul><h3 id="HUD"><a href="#HUD" class="headerlink" title="HUD"></a><a name="hud"></a>HUD</h3><ul><li>MBProgressHUD：用于显示一个半透明的 HUD。当任务在后台线程结束时可以在上边显示一个指示器和／或者标签。<a href="https://github.com/jdg/MBProgressHUD">官网</a></li><li>SVProgressHUD：一个为你的 iOS 应用制作的简洁，轻量级的进度指示 HUD。<a href="https://github.com/TransitApp/SVProgressHUD">官网</a></li><li>ProgressHUD：ProgressHUD 是一个轻量易用的 HUD。<a href="https://github.com/relatedcode/ProgressHUD">官网</a></li><li>M13ProgressSuite：一个包含了很多 iOS 上用于显示进度信息工具的套装。<a href="https://github.com/Marxon13/M13ProgressSuite">官网</a></li><li>JHProgressHUD：一个简单轻量的 Swift 框架，用于在 iOS 应用中显示★<a href="https://github.com/harikrishnant1991/JHProgressHUD">官网</a></li><li>PKHUD：用 Swift 重新实现了 Apple 的原生 HUD，支持 iOS 8 以上★<a href="https://github.com/pkluz/PKHUD">官网</a></li><li>CozyLoadingActivity：轻量的载入动作指示 HUD ★<a href="https://github.com/goktugyil/EZLoadingActivity">官网</a></li></ul><h3 id="事件总线"><a href="#事件总线" class="headerlink" title="事件总线"></a><a name="eventbus"></a>事件总线</h3><ul><li>Caravel：用于 UIWebView 和 JS 的 Swift 事件总线。★<a href="https://github.com/coshx/caravel">官网</a></li><li>  SwiftEventBus：一个针对 iOS 8 优化的发布／订阅事件总线。★<a href="https://github.com/cesarferreira/SwiftEventBus">官网</a></li><li>PromiseKit：iOS 和 OS X 上的 Promises 实现。<a href="https://github.com/mxcl/PromiseKit">官网</a></li><li>Bolts：Bolts 是一个试图使构建移动应用更简单的一个底层库集合。包括了任务（promises）和应用关联（deep links）。<a href="https://github.com/BoltsFramework/Bolts-ObjC">官网</a></li><li>SwiftTask：Swift 实现的 Promise + progress + pause + cancel + retry。 ★<a href="https://github.com/ReactKit/SwiftTask">官网</a></li></ul><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a><a name="files"></a>文件</h3><ul><li><a href="http://hao.importnew.com/filekit/">FileKit</a>：Swift 实现的简单快捷的文件管理工具。★<a href="https://github.com/nvzqz/FileKit">官网</a></li></ul><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a><a name="json"></a>JSON</h3><ul><li>JSONKit：Objective-C JSON 工具。<a href="https://github.com/johnezang/JSONKit">官网</a></li><li>TouchJSON：一个 Objective-C 的 JSON 框架。<a href="https://github.com/TouchCode/TouchJSON">官网</a></li><li>JSON-Framework：这个框架用 Objective-C 实现了一个严格的 JSON 解释器和生成器。<a href="https://github.com/stig/json-framework">官网</a></li><li>Mantle：面向 Cocoa 和 Cocoa Touch 的模型框架 Model 。<a href="https://github.com/Mantle/Mantle">官网</a></li><li>Groot：实现呃 JSON 字典或者数组和 Core Data Mangement 对象之间的转换。<a href="https://github.com/gonzalezreal/Groot">官网</a></li><li>KZPropertyMapper：以最少的代码实现数据映射和验证。<a href="https://github.com/krzysztofzablocki/KZPropertyMapper">官网</a></li><li>JSONModel：神奇的基于 JSON 的数据模型化框架。创建了一系列敏捷便利，自动并且智能的模型类。<a href="https://github.com/icanzilb/JSONModel">官网</a></li><li>SwiftyJSON：使用 Swift 处理 JSON 数据的好方法。★<a href="https://github.com/SwiftyJSON/SwiftyJSON">官网</a></li><li>FastEasyMapping：快速地序列化和反序列化 JSON 数据。<a href="https://github.com/Yalantis/FastEasyMapping">官网</a></li><li>OCMapper：Objective-C &amp; Swift 通用的快速 JSON 模型转化框架。 ★<a href="https://github.com/aryaxt/OCMapper">官网</a></li><li>ObjectMapper：在模型对象（包括 class 和 struct）和 JSON 之间转换的 Swift 框架。★<a href="https://github.com/Hearst-DD/ObjectMapper">官网</a></li><li>JASON：性能优秀操作便捷的 JSON 解析。★<a href="https://github.com/delba/JASON">官网</a></li><li>Gloss：一个 Swift 写的 JSON 解析库。★<a href="https://github.com/hkellaway/Gloss">官网</a></li><li>Cereal：Swift 对象序列化 ★<a href="https://github.com/Weebly/Cereal">官网</a></li><li>SwiftyJSONAccelerator：使用 SwiftyJSON 或者 ObjectMapper 根据 JSON 生成 Swift 模型。支持 NSCoding 并且提供了使用 JSON 来表示模型的方法。★<a href="https://github.com/insanoid/SwiftyJSONAccelerator">官网</a></li></ul><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a><a name="layout"></a>布局</h3><ul><li>ios-flexboxkit：一个封装了 Flexbox 布局的简单 UIKit 扩展。<a href="https://github.com/alexdrone/ios-flexboxkit">官网</a></li><li>Masonry：利用简单的，链式的语法发挥出自动布局 NSLayoutConstraints 的强大功能。<a href="https://github.com/SnapKit/Masonry">官网</a></li><li>FLKAutoLayout：让使用代码做约束更加简便的 UIView 类别。<a href="https://github.com/floriankugler/FLKAutoLayout">官网</a></li><li>Façade：可编程的视图布局，一个 autolayout 的替代品。<a href="https://github.com/mamaral/Facade">官网</a></li><li>PureLayout：终极的 iOS 和 OS X 上的 Autolayout API，极其简单又异常强大。同时适用于 Objective-C 和 Swift。<a href="https://github.com/PureLayout/PureLayout">官网</a></li><li>SnapKit：一个 iOS 和 OS X 的 Swift Autolayout 领域专用语言（DSL）。★<a href="https://github.com/SnapKit/SnapKit">官网</a></li><li>Cartography：一个 Swift 编写的声明式 Auto Layout 领域专用语言（DSL）。★<a href="https://github.com/robb/Cartography">官网</a></li><li>AutoLayoutPlus：给 Auto Layout 加的一点料，由 Swift 驱动。 ★<a href="https://github.com/ruipfcosta/AutoLayoutPlus">官网</a></li></ul><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a><a name="logging"></a>日志</h3><ul><li>CleanroomLogger：一个基于 Swift 可配置可扩展的日志 API，简洁、轻量并且高效。★<a href="https://github.com/emaloney/CleanroomLogger">官网</a></li><li>CocoaLumberjack：一个快捷强大灵活的日志框架，可用于 iOS &amp; Mac。<a href="https://github.com/CocoaLumberjack/CocoaLumberjack">官网</a></li><li>NSLogger：一个高性能的日志工具，它可以显示运行在 OS X、iOS 和 Android 上客户端应用的踪迹。<a href="https://github.com/fpillet/NSLogger">官网</a></li><li>Aardvark：一个高性能日志框架，它使得创建可操作的 bug 报告变得非常简单。<a href="https://github.com/square/Aardvark/">官网</a></li><li>BlockTypeDescription：在日志记录 block 的时候显示类型签名。<a href="https://github.com/conradev/BlockTypeDescription">官网</a></li><li>QorumLogs：为 Xcode 和 Google Docs 设计的 Swift 日志工具。★<a href="https://github.com/goktugyil/QorumLogs">官网</a></li></ul><h3 id="地图"><a href="#地图" class="headerlink" title="地图"></a><a name="maps"></a>地图</h3><ul><li>Route-me：iOS 开源地图框架<a href="https://github.com/route-me/route-me">官网</a></li><li>NAMapKit：允许你在 iPhone 应用使用自定义地图，并尝试模仿 Mapkit 框架的一些行为。<a href="https://github.com/neilang/NAMapKit">官网</a></li><li>Mapbox GL：一个 iOS 上使用 OpenGL 渲染 Mapbox 矢量地图块的框架。<a href="https://github.com/mapbox/mapbox-gl-native">官网</a></li><li>CMMapLauncher：用于 iOS 中在各种地图应用中显示方向的便捷框架。<a href="https://github.com/citymapper/CMMapLauncher">官网</a></li><li><a href="http://hao.importnew.com/baidu_map_ios_sdk/">百度地图iOS SDK</a>：一套功能丰富的地图开发工具包。<a href="http://lbsyun.baidu.com/index.php?title=iossdk">官网</a></li><li><a href="http://hao.importnew.com/baidu_yingyan_ios-sdk/">百度鹰眼轨迹iOS SDK</a>：一套能够进行绑路纠偏的轨迹开发工具包。<a href="http://lbsyun.baidu.com/index.php?title=ios-yingyan">官网</a></li></ul><h3 id="媒体"><a href="#媒体" class="headerlink" title="媒体"></a><a name="media"></a>媒体</h3><h5 id="图片"><a href="#图片" class="headerlink" title="图片"></a><a name="image"></a>图片</h5><ul><li>GPU Image：一个基于 GPU 的 iOS 开源的图像和视频处理框架。<a href="https://github.com/BradLarson/GPUImage">官网</a></li><li>UIImage DSP：iOS UIImage 处理功能，它使用 vDSP&#x2F;Accelerate 框架来提高速度。<a href="https://github.com/gdawg/uiimage-dsp">官网</a></li><li>QR Code Scanner：二维码扫描器。<a href="http://www.appcoda.com/qr-code-ios-programming-tutorial/">官网</a></li><li>AsyncImageView：UIImageView 的异步图像加载和显示扩展，不会阻塞 UI 线程。<a href="https://github.com/nicklockwood/AsyncImageView">官网</a></li><li>SDWebImage：异步的图像下载器，提供了缓存支持。以 UIImageView 类别的方式提供。<a href="https://github.com/rs/SDWebImage">官网</a></li><li>DFImageManager：从多种数据源获取图像的现代框架。无需配置，并具有高度的可定制性和扩展性。使用了 NSURLSession。<a href="https://github.com/kean/DFImageManager">官网</a></li><li>MapleBacon：一个 Swift iOS 图像下载和缓存库 ★<a href="https://github.com/zalando/MapleBacon">官网</a></li><li>NYTPhotoViewer：抽屉菜单和照片查看器。<a href="https://github.com/NYTimes/NYTPhotoViewer">官网</a></li><li>IDMPhotoBrowser：图片浏览器／查看器。<a href="https://github.com/ideaismobile/IDMPhotoBrowser">官网</a></li><li>JTSImageViewController：iOS 交互式图片浏览器。<a href="https://github.com/jaredsinclair/JTSImageViewController">官网</a></li><li>Concorde：下载和解码连续的 JPEG 图像。<a href="https://github.com/contentful-labs/Concorde/">官网</a></li><li>SCRecorder：类似 Vine 的点击拍摄，动画过滤器，慢镜头，片段编辑相机引擎。<a href="https://github.com/rFlex/SCRecorder">官网</a></li><li>HanekeSwift：一个 Swift 编写的 iOS 平台的轻量级通用缓存框架，还有对图像的更多支持。★<a href="https://github.com/Haneke/HanekeSwift">官网</a></li><li>TOCropViewController：一个可以允许用户修改 UIImage 对象的视图控制器。<a href="https://github.com/TimOliver/TOCropViewController">官网</a></li><li>YXTMotionView：一个自定义的图片视图，它实现了依靠设备运动来滚动图片。<a href="https://github.com/hanton/YXTMotionView">官网</a></li><li>PINRemoteImage：一个线程安全、高性能、特性丰富的图像获取器。<a href="https://github.com/pinterest/PINRemoteImage">官网</a></li><li>SABlurImageView：可以轻松地为图片添加模糊动画效果。★<a href="https://github.com/szk-atmosphere/SABlurImageView">官网</a></li><li>FastImageCache：在滚动时快速显示图片的 iOS 框架。<a href="https://github.com/path/FastImageCache">官网</a></li><li>BKAsciiImage：将图片渲染为 ASCII art 的库。<a href="https://github.com/bkoc/BKAsciiImage">官网</a></li><li>YLGIFImage：异步的 GIF 图像解码和图片浏览器。支持 GIF 图动画，但只消耗少量的内存。<a href="https://github.com/liyong03/YLGIFImage">官网</a></li><li>AlamofireImage：一个为 Alamofire 制作的图像组件库。★<a href="https://github.com/Alamofire/AlamofireImage">官网</a></li><li>Nuke：高级的图片管理框架。★<a href="https://github.com/kean/Nuke">官网</a></li><li>FlagKit：供 app 和 web 页面上使用的漂亮旗标。★<a href="https://github.com/madebybowtie/FlagKit">官网</a></li><li>YYWebImage：异步图像加载框架（支持 WebP，APNG，GIF 格式）。<a href="https://github.com/ibireme/YYWebImage">官网</a></li><li>  EFQRCode：一个纯 Swift 开发的艺术二维码生成库。★<a href="https://github.com/EyreFree/EFQRCode">官网</a></li></ul><h5 id="视频"><a href="#视频" class="headerlink" title="视频"></a><a name="video"></a>视频</h5><ul><li>VIMVideoPlayer：一个对 AVPlayer 和 AVPlayerLayer 类的简单封装。<a href="https://github.com/vimeo/VIMVideoPlayer">官网</a></li><li>MobilePlayer：一个强大完善且完全可定制的 iOS 媒体播放器。<a href="https://github.com/mobileplayer/mobileplayer-ios">官网</a></li></ul><h5 id="PDF"><a href="#PDF" class="headerlink" title="PDF"></a><a name="pdf"></a>PDF</h5><ul><li>Reader：一个 iOS PDF 阅读器的核心。<a href="https://github.com/vfr/Reader">官网</a></li><li>UIView 2 PDF：使用 UIViews （或配合着 XIB）的 PDF 生成器。<a href="https://github.com/RobertAPhillips/UIView_2_PDF">官网</a></li></ul><h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a><a name="messaging"></a>消息</h3><ul><li>LayerKit：一个对于 Layer 的 iOS 开发组件,。是将消息（文字，照片，视频，数据）添加到移动或 Web 应用中最简单的解决方案。<a href="https://github.com/layerhq/releases-ios">官网</a></li><li>Twilio：驱动着现代的交流方式，构建下一代音频与 SMS 应用。<a href="https://www.twilio.com/">官网</a></li><li>Plivo：SMS API、音频 API 和 全球运营商。<a href="https://www.plivo.com/">官网</a></li><li>XMPPFramework：一个 iOS 和 Mac 上的 XMPP 协议通讯框架。<a href="https://github.com/robbiehanson/XMPPFramework">官网</a></li></ul><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a><a name="networking"></a>网络</h3><ul><li>AFNetworking：一个得心应手的 iOS 和 OSX 上的网络请求框架。<a href="https://github.com/AFNetworking/AFNetworking">官网</a></li><li>RestKit：RestKit 是一个 iOS Objective-C 框架，是为了让和 RESTful web 服务交互变的简单、快捷、有趣。<a href="https://github.com/RestKit/RestKit">官网</a></li><li>FSNetworking：稳固的 iOS 网络库。<a href="https://github.com/foursquare/FSNetworking">官网</a></li><li>ASIHTTPRequest：Objective-C 编写的 HTTP 网络请求库。它是对 CFNetwork 易用的封装。支持 Mac OS X 和 iPhone。<a href="https://github.com/pokeb/asi-http-request">官网</a></li><li>Overcoat：小巧但是很强大的库，让创建一个 REST 客户端简便和有趣。<a href="https://github.com/Overcoat/Overcoat">官网</a></li><li>ROADFramework：面向属性的 web 服务交互方式。框架有内建的 json 和 xml 请求响应序列化方法，十分方便扩展。<a href="https://github.com/epam/road-ios-framework">官网</a></li><li>MBNetworkMonitor：苹果 <code>Reachability</code> 类的现代化替代品，使用了 <code>CoreTelephony</code> 来传达更多<a href="https://rawgit.com/emaloney/MBToolbox/master/Documentation/html/Classes/MBNetworkMonitor.html">有关用户网络连接状况的信息</a>。<a href="https://github.com/emaloney/MBToolbox/blob/master/Code/Network/MBNetworkMonitor.h">官网</a></li><li>MBNetworkIndicator：提供了简单的方式<a href="https://rawgit.com/emaloney/MBToolbox/master/Documentation/html/Classes/MBNetworkIndicator.html">在多个请求之间协调设备网络指示器</a>。<a href="https://github.com/emaloney/MBToolbox/blob/master/Code/Network/MBNetworkIndicator.h">官网</a></li><li>Alamofire：Alamofire 是一个 Swift 写的 HTTP 网络库，由 AFNetworking 的作者编写。★<a href="https://github.com/Alamofire/Alamofire">官网</a></li><li>Transporter：让上传下载更便捷的小代码库。★<a href="https://github.com/nghialv/Transporter">官网</a></li><li>CDZPinger：使用方便的 ICMP Ping 框架。<a href="https://github.com/cdzombak/CDZPinger">官网</a></li><li>NSRails：将客户端的对象／类映射到远程 REST API 的对象／ORM。<a href="https://github.com/dingbat/nsrails">官网</a></li><li>NKMultipeer：一个建立在多重链接上的可测试的抽象。★<a href="https://github.com/nathankot/NKMultipeer">官网</a></li><li>CocoaAsyncSocket：用于 Mac 和 iOS 的异步 socket 网络库。<a href="https://github.com/robbiehanson/CocoaAsyncSocket">官网</a></li><li>Siesta：优雅的 RESTful 资源抽象，将状态解藕。是基于回调或者代理的网络库的替代品。★<a href="https://bustoutsolutions.github.io/siesta/">官网</a></li><li>Reachability.swift：用 Swift 和闭包重新实现了苹果的 Reachablility 框架。★<a href="https://github.com/ashleymills/Reachability.swift">官网</a></li><li>NetworkEye：一个 iOS 网络调试库，可以显示 App 中的 HTTP 请求和请求的相关信息。<a href="https://github.com/coderyi/NetworkEye">官网</a></li></ul><h3 id="推送通知"><a href="#推送通知" class="headerlink" title="推送通知"></a><a name="push-notifications"></a>推送通知</h3><ul><li>Orbiter：在 iOS 中注册推送通知。<a href="https://github.com/mattt/Orbiter">官网</a></li><li>PEM：为推送服务器自动生成 profile。<a href="https://github.com/fastlane/PEM">官网</a></li><li>Parse Push：完全免费的后台推送通知，提供了创建分段，调度甚至 A&#x2F;B 测试的能力。<a href="https://parse.com/products/push">官网</a></li><li>Urban Airship：付费的推送通知后台。<a href="https://www.urbanairship.com/products/platform#push-messages">官网</a></li><li>Growth Push：付费的推送通知。 它是在日本最受开发者喜爱的工具之一。<a href="https://growthpush.com/">官网</a></li><li>APNS-Pusher：苹果推送通知服务的调试器。<a href="https://github.com/KnuffApp/Knuff">官网</a></li></ul><h3 id="Passbook"><a href="#Passbook" class="headerlink" title="Passbook"></a><a name="passbook"></a>Passbook</h3><ul><li>passbook：为 Passbook 创建 pkpass 文件。<a href="https://github.com/frozon/passbook">官网</a></li><li>Dubai：生成和预览 Passbook 的 Pass。<a href="https://github.com/nomad/dubai">官网</a></li><li>Passkit：设计、创建并验证 Passbook 的 Pass。<a href="https://passkit.com/">官网</a></li></ul><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a><a name="permissions"></a>权限</h3><ul><li>PermissionScope：智能的 iOS 授权 UI 和 统一的 API（支持位置、通知、照片、联系人、日历、照片、麦克风、BT、进度指示、HealthKit 和 CloudKit）。★<a href="https://github.com/nickoneill/PermissionScope">官网</a></li><li>Proposer：便捷地请求用户权限（支持相机、照片、麦克风、联系人、位置）。★<a href="https://github.com/nixzhu/Proposer">官网</a></li><li>ICanHas：简化 iOS 用户权限请求（支持位置、推送通知、相机、联系人、日历、照片）。★<a href="https://github.com/wircho/ICanHas">官网</a></li><li>VWWPermissionKit：可视化的 iOS 授权管理器。<a href="https://github.com/zakkhoyt/VWWPermissionKit">官网</a></li><li>ISHPermissionKit：为 iOS 提供请求用户权限的统一方法。<a href="https://github.com/iosphere/ISHPermissionKit">官网</a></li><li>JLPermissions：iOS 预授权工具，开发者用它来制作询问用户是否授权的对话框，支持日历、联系人、位置、照片、备忘录、twitter、推送通知和其他需要授权的操作。<a href="https://github.com/jlaws/JLPermissions">官网</a></li></ul><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a><a name="text"></a>文本</h3><ul><li>Twitter Text Obj：Twitter 的文本处理库的 Objective-C 实现。<a href="https://github.com/twitter/twitter-text">官网</a></li><li>Nimbus：Nimbus 是一个为高级 iOS 软件设计师制作工具包。<a href="http://nimbuskit.info/">官网</a></li><li>NSStringEmojize：一个将 Emoji 表情符号转换为等价的 Unicode 字串的 NSString 类别。<a href="https://github.com/diy/nsstringemojize">官网</a></li><li>MMMarkdown：用于将 Markdown 转换为 HTML 的 Objective-C 静态库。<a href="https://github.com/mdiep/MMMarkdown">官网</a></li><li>DTCoreText：利用 CoreText 使用 HTML 代码的方法。<a href="https://github.com/Cocoanetics/DTCoreText">官网</a></li><li>DTRichTextEditor：一个 iOS 的富文本编辑器。<a href="https://github.com/Cocoanetics/DTRichTextEditor">官网</a></li><li>NBEmojiSearchView：一个支持搜索并且可以集成到文本控件中的 emoji 下拉列表视图。<a href="https://github.com/neerajbaid/NBEmojiSearchView">官网</a></li><li>ios-fontawesome：NSString + FontAwesome。<a href="https://github.com/alexdrone/ios-fontawesome">官网</a></li><li>Pluralize.swift：强大的 Swift String 单数转换复数扩展。★<a href="https://github.com/joshualat/Pluralize.swift">官网</a></li><li>RichEditorView：RichEditorView 是一个简单、模块化的富文本编辑器视图。★<a href="https://github.com/cjwirth/RichEditorView">官网</a></li><li>Money：为与钱和现金相关工作的的 Swift 值类型。★<a href="https://github.com/danthorpe/Money">官网</a></li><li>PhoneNumberKit：用于解析，格式化和验证国际电话号码的 Swift 框架，由谷歌的 libphonenumber 库支持。★<a href="https://github.com/marmelroy/PhoneNumberKit">官网</a></li><li>YYText：iOS 上用于显示和编辑富文本的强大文本框架。<a href="https://github.com/ibireme/YYText">官网</a></li></ul><h3 id="功能漫游-介绍-教程"><a href="#功能漫游-介绍-教程" class="headerlink" title="功能漫游 &#x2F; 介绍 &#x2F; 教程"></a><a name="walkthrough--intro--tutorial"></a>功能漫游 &#x2F; 介绍 &#x2F; 教程</h3><ul><li>Onboard：用一点点代码就可以创建一个漂亮的吸附效果的实践。<a href="https://github.com/mamaral/Onboard">官网</a></li><li>EAIntroView：高度可定制非侵入式的欢迎页面解决方案。<a href="https://github.com/ealeksandrov/EAIntroView">官网</a></li><li>MYBlurIntroductionView：在 MYIntroductionView 上完善的，用于构建可定制的 app 介绍或者教程页面的框架。<a href="https://github.com/MatthewYork/MYBlurIntroductionView">官网</a></li><li>BWWalkthrough：一个自定义 iOS App 的功能漫游页面的框架。★<a href="https://github.com/ariok/BWWalkthrough">官网</a></li><li>GHWalkThrough：一个基于 UICollectionView 的非侵入式介绍页面组件。<a href="https://github.com/GnosisHub/GHWalkThrough">官网</a></li><li>ICETutorial：一个很好的教程框架，类似 Path 3.X 版本的 App 中的样式。<a href="https://github.com/icepat/ICETutorial">官网</a></li><li>JazzHands：Jazz Hands 是一个简单的 UIKit 关键帧动画框架。动画是可以使用手势、滚动视图、KVO 或者 ReactiveCocoa 来控制的。<a href="https://github.com/IFTTT/JazzHands">官网</a></li><li>RazzleDazzle：简单的基于关键帧的 iOS 动画框架，由 Swift 编写。最适合用于 App 的滚动介绍页面。★<a href="https://github.com/IFTTT/RazzleDazzle">官网</a></li><li>Instructions：向你的 iOS 项目中添加自定义的操作方式指导的简单办法。★<a href="https://github.com/ephread/Instructions">官网</a></li><li>SwiftyWalkthrough：创建一个体验绝佳的功能漫游的最简单方法，Swift 编写。★<a href="https://github.com/ruipfcosta/SwiftyWalkthrough">官网</a></li></ul><h3 id="URL-Scheme"><a href="#URL-Scheme" class="headerlink" title="URL Scheme"></a><a name="url-scheme"></a>URL Scheme</h3><ul><li>WAAppRouting：iOS 的路由实现。同时处理了 URL 识别和利用控制器显示解析后的参数。全部这些只要一行代码就可以搞定，控制器堆栈还会被自动保留！<a href="https://github.com/Wasappli/WAAppRouting">官网</a></li><li>DeepLinkKit：杰出的路由匹配框架，使用基于 block API 处理你的深链接。<a href="https://github.com/usebutton/DeepLinkKit">官网</a></li><li>IntentKit：一个便捷的方法来在 iOS app 中处理第三方 URL schemes。<a href="https://github.com/intentkit/IntentKit">官网</a></li><li>JLRoutes：使用了 block API 的 iOS URL 路由框架。<a href="https://github.com/joeldev/JLRoutes">官网</a></li></ul><h3 id="UI"><a href="#UI" class="headerlink" title="UI"></a><a name="ui"></a>UI</h3><ul><li>Chameleon：一个 iOS 性能强大的轻量级扁平化颜色框架，可以用于 Objective-C 和 Swift。★<a href="https://github.com/ViccAlexander/Chameleon">官网</a></li><li>ActionSheetPicker-3.0：为 iOS App 快速制作一个下拉 UIPickerView &#x2F; ActionSheet 功能。<a href="https://github.com/skywinder/ActionSheetPicker-3.0/">官网</a></li><li>FlatUIKit：适用于 iOS 的扁平化 UI 组件集合。<a href="https://github.com/Grouper/FlatUIKit">官网</a></li><li>JVFloatLabeledTextField：附有浮动标签的 UITextField 子类。<a href="https://github.com/jverdi/JVFloatLabeledTextField">官网</a></li><li>SSBouncyButton：有弹性的 iOS7 样式按钮 UI 组件。<a href="https://github.com/StyleShare/SSBouncyButton">官网</a></li><li>BetweenKit：一个健壮的 iOS 拖拽框架。<a href="https://github.com/ice3-software/between-kit">官网</a></li><li>JSQMessagesViewController：一个优雅的 iOS 聊天消息 UI 库。<a href="https://github.com/jessesquires/JSQMessagesViewController">官网</a></li><li>AMSmoothAlert：一个很 cool 的 AlertView。<a href="https://github.com/mtonio91/AMSmoothAlert">官网</a></li><li>TSMessages：在屏幕上方显示通知（比如成功、错误、警告或者消息）视图。<a href="https://github.com/KrauseFx/TSMessages">官网</a></li><li>NZAlertView：简单直观的 AlertView。类似推送通知的效果。<a href="https://github.com/NZN/NZAlertView">官网</a></li><li>MGSwipeTableCell：可以显示滑动按钮的 UITableViewCell 的子类，还支持多种过渡动画。<a href="https://github.com/MortimerGoro/MGSwipeTableCell">官网</a></li><li>ARAutocompleteTextView：subclass of 实时显示文本提示的 UITextView 的子类。完美支持 e-mail 格式。<a href="https://github.com/alexruperez/ARAutocompleteTextView">官网</a></li><li>TGCameraViewController：基于 AVFoundation 的自定义相机。样式漂亮，轻量并且可以很容易地集成到 iOS 项目中。<a href="https://github.com/tdginternet/TGCameraViewController">官网</a></li><li>ENSwiftSideMenu：一个 Swift 写的简洁 iOS7&#x2F;8 侧滑菜单。★<a href="https://github.com/evnaz/ENSwiftSideMenu">官网</a></li><li>MDCSwipeToChoose：滑动卡片来决定 “喜欢” 或者 “不喜欢” 的控件，效果类似 Tinder App。可以用于在几分钟内创建识字卡 app，图片浏览器或者其他类似应用，而不用几小时。<a href="https://github.com/modocache/MDCSwipeToChoose">官网</a></li><li>ParallaxTableViewHeader：UITableView header 的视差滚动效果组件。<a href="https://github.com/Vinodh-G/ParallaxTableViewHeader">官网</a></li><li>JLToast：iOS 的 Toast 组件，提供了简单的接口。★<a href="https://github.com/devxoul/JLToast">官网</a></li><li>SweetAlert：为 iOS 应用提供了实时动画效果的 AlertView，Swift 编写而成。★<a href="https://github.com/codestergit/SweetAlert-iOS">官网</a></li><li>Form：JSON 驱动的列表控件。<a href="https://github.com/hyperoslo/Form">官网</a></li><li>BLKFlexibleHeightBar：创建一个高度可以自动调整的 NavigationBar，类似 Facebook ，Square Cash，Safari 中的那样。<a href="https://github.com/bryankeller/BLKFlexibleHeightBar">官网</a></li><li>NMPopUpView：用于显示浮动窗口的简单 iOS 类。支持 Swift 和 Objective-C。★<a href="https://github.com/psy2k/NMPopUpView">官网</a></li><li>SDevIconFonts：用于 Swift 的 Fontawesome, Iconic, Ionicons, Octicon。★<a href="https://github.com/0x73/SDevIconFonts">官网</a></li><li>SDevBootstrapButton：Swift 版的 Twitter Bootstrap 按钮。★<a href="https://github.com/0x73/SDevBootstrapButton">官网</a></li><li>SDevCircleButton：Swift 实现的圆型按钮。★<a href="https://github.com/0x73/SDevCircleButton">官网</a></li><li>SDevFlatColors：Swift 实现的扁平化颜色。★<a href="https://github.com/0x73/SDevFlatColors">官网</a></li><li>ColorArt：从图片中取出主要颜色，类似 iTunes 11 的效果。<a href="https://github.com/vinhnx/ColorArt">官网</a></li><li>IQKeyboardManager：防止键盘滑出来遮挡住 UITextField&#x2F;UITextView 的框架，非侵入，无需代码。<a href="https://github.com/hackiftekhar/IQKeyboardManager">官网</a></li><li>WCFastCell：滚动流畅的 Tables&#x2F;Collections cell (没有动画)。<a href="https://github.com/wczekalski/WCFastCell">官网</a></li><li>Motif：一个基于 JSON 的可定制轻量级样式表框架。<a href="https://github.com/erichoracek/Motif">官网</a></li><li>VBFPopFlatButton：基于 Facebook POP制作的，有9种不同状态动画的扁平化按钮。<a href="https://github.com/victorBaro/VBFPopFlatButton">官网</a></li><li>HTPressableButton：扁平化设计的可以按压的按钮。<a href="https://github.com/herinkc/HTPressableButton">官网</a></li><li>Cool-iOS-Camera：一个完全可定制的现代的照相机，使用 AVFoundation 框架实现。<a href="https://github.com/GabrielAlva/Cool-iOS-Camera">官网</a></li><li>AsyncDisplayKit：AsyncDisplayKit 是一个 iOS 框架，它能够使一个很复杂的用户界面保持平滑和反应灵敏。<a href="https://github.com/facebook/AsyncDisplayKit/">官网</a></li><li>AMTagListView：一个可以添加一系列高度可定制化的标签的 UIScrollView 子类。<a href="https://github.com/andreamazz/AMTagListView">官网</a></li><li>MotionBlur：MotionBlur 让你可以在 iOS 动画效果上添加模糊效果。<a href="https://github.com/fastred/MotionBlur">官网</a></li><li>PBJVision：iOS 相机引擎，支持点击拍摄，慢动作视频和图片捕捉功能。<a href="https://github.com/piemonte/PBJVision">官网</a></li><li>DynamicColor：又一个用于操作颜色的 Swift 扩展。★<a href="https://github.com/yannickl/DynamicColor">官网</a></li><li>GaugeKit：可定制的仪表组件，可以方便地仿制苹果样式的仪表盘。★<a href="https://github.com/skywinder/GaugeKit">官网</a></li><li>SVWebViewController：一个非侵入式的内置浏览器。<a href="https://github.com/TransitApp/SVWebViewController">官网</a></li><li>SwiftWebVC：一个 SVWebViewController 的 Swift 实现。★<a href="https://github.com/meismyles/SwiftWebVC">官网</a></li><li>MVAutocompletePlaceSearchTextField：一个类似 Google Places，Uber 等位置搜索的非侵入式自动完成控件。<a href="https://github.com/mrugrajsinh/MVAutocompletePlaceSearchTextField">官网</a></li><li>MVMaterialView：用来模仿 Material Design 概念波纹（Ripple）效果 UI 控件的子类和 UIButton。<a href="https://github.com/mrugrajsinh/MVMaterialView">官网</a></li><li>Atlas：为 Layer 设计的原生 iOS 消息应用 UI 组件。<a href="https://github.com/layerhq/Atlas-iOS">官网</a></li><li>Swift-Prompts：用来设计自定义提示的 Swift 库，有很大的范围可供选择。★<a href="https://github.com/GabrielAlva/Swift-Prompts">官网</a></li><li>IQDropDownTextField：提供了下拉 UIPickerView 支持的 UITextField。<a href="https://github.com/hackiftekhar/IQDropDownTextField">官网</a></li><li>PJAlertView：苹果弃用了原来好用的警告视图，让我们失去了很多的定制性，这个库重新将定制性带回来。<a href="https://github.com/PrajeetShrestha/PJAlertView">官网</a></li><li>CZPicker：iOS 的 Popup 样式的 UIPickerView.<a href="https://github.com/chenzeyu/CZPicker">官网</a></li><li>TisprCardStack：卡片 UI 库。★<a href="https://github.com/tispr/tispr-card-stack">官网</a></li><li>YXTPageView：一个支持 UIView 和 UITableView 之间滚动切换的 PageView。<a href="https://github.com/hanton/YXTPageView">官网</a></li><li>DatePickerDialog：在 UIAlertView 上显示 UIDatePicker 的 Swift 库。★<a href="https://github.com/squimer/DatePickerDialog-iOS-Swift">官网</a></li><li>gifu：iOS 上支持动态 GIF 的 Swift 框架。★<a href="https://github.com/kaishin/gifu">官网</a></li><li>SAHistoryNavigationViewController：SAHistoryNavigationViewController 实现了一个在 iOS 上的类似任务管理器的 UI，兼容 UINavigationContoller,3D Touch。★<a href="https://github.com/szk-atmosphere/SAHistoryNavigationViewController">官网</a></li><li>DOFavoriteButton：一个可爱的动画按钮。★<a href="https://github.com/okmr-d/DOFavoriteButton">官网</a></li><li>LNRSimpleNotifications：简单的 Swift app 内置通知。LNRSimpleNotifications 是一个 Swift <a href="https://github.com/KrauseFx/TSMessages">TSMessages</a> 简化版本。 ★<a href="https://github.com/LISNR/LNRSimpleNotifications">官网</a></li><li>NgKeyboardTracker：iOS 的键盘跟踪 Objective-C 库。<a href="https://github.com/meiwin/NgKeyboardTracker">官网</a></li><li>SAInboxViewController：受到 “Inbox by google” 动画过渡效果启发的 UIViewController 子类。★<a href="https://github.com/szk-atmosphere/SAInboxViewController">官网</a></li><li>TLYShyNavBar：不像那些 UINavigationBar 那么傲慢。这个 Bar 很谦虚！可以很容易地创建自动滚动的 navigation bar。<a href="https://github.com/telly/TLYShyNavBar">官网</a></li><li>BRYXBanner：Swift 的 iOS7+ 样式的下拉通知。 ★<a href="https://github.com/bryx-inc/BRYXBanner">官网</a></li><li>NYAlertViewController：可以自定义内容视图的 iOS AlertView，可高度自定义。<a href="https://github.com/nealyoung/NYAlertViewController">官网</a></li><li>HDNotificationView：使用模仿原生的通知横幅 UI，发出任何警告。<a href="https://github.com/nhdang103/HDNotificationView">官网</a></li><li>MZFormSheetPresentationController：MZFormSheetPresentationController 提供了一个原生 iOS UIModalPresentationFormSheet 的替代品，添加了对 iPhone 的支持，并且可以自定义 controller 的尺寸和表单的外观。<a href="https://github.com/m1entus/MZFormSheetPresentationController">官网</a></li><li>AnimatedTransitionGallery：使用 UIViewControllerAnimatedTransitioning 协议实现了自定义 iOS 7 过渡动画。<a href="https://github.com/shu223/AnimatedTransitionGallery">官网</a></li><li>iCarousel：iOS 和 Mac OS 上简单的，高度可定制化的数据驱动 3D 跑马灯。<a href="https://github.com/nicklockwood/iCarousel">官网</a></li><li>RESideMenu：受 Dribble 上的设计启发而制作的 iOS 7&#x2F;8 样式的视差侧滑菜单。<a href="https://github.com/romaonthego/RESideMenu">官网</a></li><li>FontAwesomeKit：iOS 的图标字体库，现在支持 Font-Awesome，Foundation icons，Zocial 和 ionicons。<a href="https://github.com/PrideChung/FontAwesomeKit">官网</a></li><li>Cocoa Controls：开源的 iOS 和 OS X UI 组件.<a href="https://www.cocoacontrols.com/">官网</a></li><li>ActiveLabel.swift：非侵入的 UILabel 替代品，支持 Hashtags (#), Mentions (@) 和 URL (http:&#x2F;&#x2F; )。 ★<a href="https://github.com/optonaut/ActiveLabel.swift">官网</a></li><li>XLForm：XLForm 是最灵活强大的 iOS 库，用来创建动态的 tableview 表单，完全适用于 Swift 和 Obj-C。<a href="https://github.com/xmartlabs/XLForm">官网</a></li><li>RAReorderableLayout：可以拖拽放置的 UICollectionView 元素。<a href="https://github.com/ra1028/RAReorderableLayout">官网</a></li><li>ESTabBarController：一个允许高亮按钮和自定义按钮动作的 Tabbar 控制器。<a href="https://github.com/ezescaruli/ESTabBarController">官网</a></li><li>STPopup：STPopup 为 iPhone 和 iPad 提供了一个 popup 样式的 UINavigationController。<a href="https://github.com/kevin0571/STPopup">官网</a></li><li>HoneycombView：HoneycombView 是用来显示类似 Honyecomb 布局的 iOS UIView，由 Swift 实现。★<a href="https://github.com/suzuki-0000/HoneycombView">官网</a></li><li>tapkulibrary：tap + haiku &#x3D; tapku, 一个精心设计的 iOS 开源框架。<a href="https://github.com/devinross/tapkulibrary">官网</a></li><li>NVActivityIndicatorView：很好的加载动画集合。★<a href="https://github.com/ninjaprox/NVActivityIndicatorView">官网</a></li><li>KCJogDial：提供控制功能的 UIView，类似一个转轮控制器。★<a href="https://github.com/kciter/KCHorizontalDial">官网</a></li><li>PagingMenuController：有可定制的菜单的分页视图控制器，Swift 实现。★<a href="https://github.com/kitasuke/PagingMenuController">官网</a></li><li>RadialMenu：RadialMenu 是一个提供了触控的上下文菜单（类似 iOS8 中 iMessage 的录制按钮）的自定义控件。使用 Swift 和 POP 框架构建。★<a href="https://github.com/bradjasper/radialmenu">官网</a></li><li>VLDContextSheet：类似 Pinterest iOS app 中的菜单。<a href="https://github.com/vangelov/VLDContextSheet">官网</a></li><li>cariocamenu：最快的无点击菜单。★<a href="https://github.com/arn00s/cariocamenu">官网</a></li><li>DAExpandAnimation：以自定义的模态过渡效果，从 cell 中展开来呈现控制器的库。★<a href="https://github.com/ifitdoesntwork/DAExpandAnimation">官网</a></li><li>ScrollPager：类似 Flipboard 的滚动翻页。★<a href="https://github.com/aryaxt/ScrollPager">官网</a></li><li>ComponentKit：受到 React 启发的 iOS 框架，Facebook 出品A React-Inspired View Framework for iOS, by Facebook.<a href="http://componentkit.org/">官网</a></li><li>Eureka：使用纯 Swift 构建优雅的 iOS 表单。★<a href="https://github.com/xmartlabs/Eureka">官网</a></li><li>PMTween：优雅灵活的 iOS 渐变库。<a href="https://github.com/poetmountain/PMTween">官网</a></li><li>MZTimerLabel：让 UILabel 变成 倒计时器或者秒表的便利类，类似苹果的时钟应用。<a href="https://github.com/mineschan/MZTimerLabel">官网</a></li><li>WobbleView：WobbleView 是一个实现了流行的摇晃效果的视图。你可以在应用中方便的添加动态的用户交互和过渡效果。★<a href="https://github.com/inFullMobile/WobbleView">官网</a></li><li>CBZSplashView：Twitter 样式的启动页（Splash Screen）视图，缩放后显示主视图。<a href="https://github.com/callumboddy/CBZSplashView">官网</a></li><li>RKNotificationHub：让任何 UIView 变成完善的通知中心。<a href="https://github.com/cwRichardKim/RKNotificationHub">官网</a></li><li>EatFit：Eat fit 是一个受 Google Fit 启发的用于漂亮地展示数据的组件。<a href="https://github.com/Yalantis/EatFit">官网</a></li><li>CollapsableTable：可以自定义 section header 的可折叠 tableview section。★<a href="https://github.com/rob-nash/CollapsableTable">官网</a></li><li>LiquidFloatingActionButton：流体状态的 Material Design 的浮动按钮。<a href="https://github.com/yoavlt/LiquidFloatingActionButton">官网</a></li><li>LiquidLoader：液体动画的加载器组件。★<a href="https://github.com/yoavlt/LiquidLoader">官网</a></li><li>PickerView：Swift 实现的自定义的 UIPickerView 替代品。★<a href="https://github.com/filipealva/PickerView">官网</a></li><li>InteractivePlayerView：自定义的 iOS 音乐播放器视图。★<a href="https://github.com/AhmettKeskin/InteractivePlayerView">官网</a></li><li>phone-number-picker：一个 Swift 实现的简单易用的视图控制器，类似 WhatsApp 那样让你输入带有国家代码电话号码。★<a href="https://github.com/hughbe/phone-number-picker">官网</a></li><li>DLWBouncyView：BouncyView 是一个为所有视图都实现了最近流行的弹性效果的框架。<a href="https://github.com/cute/DLWBouncyView">官网</a></li><li>MMPopupView：基于 Pop-up 的视图(例如，AlertSheet)，支持方便地定制。<a href="https://github.com/adad184/MMPopupView">官网</a></li><li>EXTView：使用 IB_DESIGNABLE 和 IBInspectable 为 Interface Builder 提供了 UIView 扩展。<a href="https://github.com/recruit-mtl/EXTView">官网</a></li><li>JTMaterialSwitch：一个受 Google 的 Material Design 启发的可定制的开关 UI，有波纹效果和弹性动画。<a href="https://github.com/JunichiT/JTMaterialSwitch">官网</a></li><li>PickerView：Swift 写的可定制的 UIPickerView 替代品。<a href="https://github.com/filipealva/PickerView">官网</a></li><li>KCSelectionDialog：简单的选择对话框。★<a href="https://github.com/kciter/KCSelectionDialog">官网</a></li><li>SFFocusViewLayout：支持内容聚焦的 UICollectionViewLayout。<a href="https://github.com/fdzsergio/SFFocusViewLayout">官网</a></li><li>UITextField-Shake：添加了摇晃动画的 UITextField 类别。<a href="https://github.com/King-Wizard/UITextField-Shake-Swift">也有 Swift 版本</a> ★<a href="https://github.com/andreamazz/UITextField-Shake">官网</a></li><li>JTFadingInfoView：一个基于 UIButton 的支持淡入淡出动画特性的视图。<a href="https://github.com/JunichiT/JTFadingInfoView">官网</a></li><li>KCFloatingActionButton：简洁的 iOS 浮动操作按钮。★<a href="https://github.com/kciter/KCFloatingActionButton">官网</a></li><li>TTGSnackbar：在屏幕底部显示简单的消息和操作按钮，支持多种动画效果。★<a href="https://github.com/zekunyan/TTGSnackbar">官网</a></li><li>TTGEmojiRate：iOS 的类似 emoji 的评分视图。★<a href="https://github.com/zekunyan/TTGEmojiRate">官网</a></li><li>CardAnimation：卡片翻页动画效果。★<a href="https://github.com/seedante/CardAnimation">官网</a></li><li>BEMCheckBox：优雅的 iOS 复选框。(Check box)<a href="https://github.com/Boris-Em/BEMCheckBox#sample-app">官网</a></li><li>CVCalendar：支持 iOS 8+ 的自定义可视化日历，Swift（2.0）实现。★<a href="https://github.com/Mozharovsky/CVCalendar">官网</a></li><li>JTAppleCalendar: 最好的iOS版雨燕日历库 ★<a href="https://github.com/patchthecode/JTAppleCalendar">官网</a></li><li>SCLAlertView-Swift：Swift 实现的一个漂亮的动画 Alert View。★<a href="https://github.com/vikmeup/SCLAlertView-Swift">官网</a></li><li>Atlas-iOS：Atlas 是一个原生 iOS 对话 UI Layer 组件。<a href="https://atlas.layer.com/ios">官网</a></li><li>TKRubberIndicator：Swift 版橡胶 PageControl 指示器。 <a href="http://tbxark.github.io/">http://tbxark.github.io</a> ★<a href="https://github.com/TBXark/TKRubberIndicator">官网</a></li><li>HorizontalProgress：简单的动画水平进度条。<a href="https://github.com/AliThink/HorizontalProgress">官网</a></li><li>TKSwitcherCollection：一个动画开关集合。<a href="http://tbxark.github.io/">http://tbxark.github.io</a> ★<a href="https://github.com/TBXark/TKSwitcherCollection">官网</a></li><li>JDSwiftAvatarProgress：方便自定义的异步加载展位图进度条动画。★<a href="https://github.com/JellyDevelopment/JDSwiftAvatarProgress">官网</a></li><li>iOS-CircleProgressView：这个空间允许用户用代码或者 interface builder 初始化或创建并渲染一个圆形的进度条视图。★<a href="https://github.com/CardinalNow/iOS-CircleProgressView">官网</a></li><li>Hamburger-Menu-Button：一个高度可定制的汉堡包菜单按钮。★<a href="https://github.com/toannt/Hamburger-Menu-Button">官网</a></li><li>DGElasticPullToRefresh：iOS 弹性下拉刷新控件，Swift 实现。★<a href="https://github.com/gontovnik/DGElasticPullToRefresh">官网</a></li><li>HTYTextField：一个有弹性的站位文字的 UITextField。★<a href="https://github.com/hanton/HTYTextField">官网</a></li><li>JDStatusBarNotification：显示在顶部状态栏的通知，使用简单，可以自定义。<a href="https://github.com/jaydee3/JDStatusBarNotification">官网</a></li><li>GuillotineMenu：铡刀样式过渡动画的下拉菜单。★<a href="https://github.com/Yalantis/GuillotineMenu/tree/swift_2.0">官网</a></li><li>MediumMenu：一个基于 Medium iOS 应用的菜单。★<a href="https://github.com/pixyzehn/MediumMenu">官网</a></li><li>YALField：使用 interface builder 更容易地创建表单 UI。包含带合法性验证的自定义字段。<a href="https://github.com/Yalantis/YALField?utm_campaign=Indie+iOS+Focus+Weekly&amp;utm_medium=email&amp;utm_source=Indie_iOS_Focus_Weekly_43">官网</a></li><li>StarryStars：iOS GUI 库，用于显示和编辑评分。<a href="https://github.com/peterprokop/StarryStars?utm_campaign=explore-email&amp;utm_medium=email&amp;utm_source=newsletter&amp;utm_term=daily">官网</a></li><li>JRSplitVC：自适应布局的 UISplitViewController。<a href="https://github.com/tommypeps/JRSplitVC">官网</a></li><li>SevenSwitch：非侵入式的 iOS7 样式的开关替代品。★<a href="https://github.com/bvogelzang/SevenSwitch">官网</a></li><li>RadialLayer：可点击元素的动画。★<a href="https://github.com/soheil/RadialLayer">官网</a></li><li>MPParallaxView：Swift 实现的 Apple TV 视差效果。★<a href="https://github.com/DroidsOnRoids/MPParallaxView">官网</a></li><li>RPLoadingAnimation：Swift 实现的基于 CALayer 的加载动画。★<a href="https://github.com/naoyashiga/RPLoadingAnimation">官网</a></li><li>Splitflap：Swift 应用的分屏显示框架。★<a href="https://github.com/yannickl/Splitflap">官网</a></li><li>UIScrollView-InfiniteScroll：支持无限滚动的 UIScrollView 类别。★<a href="https://github.com/pronebird/UIScrollView-InfiniteScroll">官网</a></li><li>PullToBounce：UIScrollView 的下拉刷新控件。★<a href="https://github.com/entotsu/PullToBounce">官网</a></li><li>TVButton：重新创造一个非常酷的 Apple TV 视差图标用在 iOS UIButton 上（Swift 实现）。★<a href="https://github.com/marmelroy/TVButton">官网</a></li><li>SlackTextViewController：一个非侵入式的 UIViewcontroller 子类，提供了一个可以随文字长度变化的大小的文本框和一些其他有用的消息特性。<a href="https://github.com/slackhq/SlackTextViewController">官网</a></li><li>EZAlertController：便捷的 Swift UIAlertController。★<a href="https://github.com/thellimist/EZAlertController">官网</a></li><li>EZSwipeController：<img src="/myblog/images/pointer.png.png">类似 Snapchat&#x2F;Tinder&#x2F;iOS 主页的 UIPageViewController。★<a href="https://github.com/goktugyil/EZSwipeController">官网</a></li><li>SWRevealViewController：受到 FaceBook 和 Wunderlist 应用启发的 UIViewController 子类，用于显示侧滑的视图控制器。<a href="https://github.com/John-Lluch/SWRevealViewController">官网</a></li></ul><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a><a name="websocket"></a>WebSocket</h3><ul><li>Socket Rocket：一个一致的 Objective-C WebSocket 客户端库。<a href="https://github.com/square/SocketRocket">官网</a></li></ul><h3 id="代码质量"><a href="#代码质量" class="headerlink" title="代码质量"></a><a name="code-quality"></a>代码质量</h3><ul><li>KZBootstrap：一系列的脚本和注释，代码质量很差时，在编译时产生额外的错误和警告。<a href="https://github.com/krzysztofzablocki/KZBootstrap">官网</a></li><li>KZAsserts：一系列的自定义断言，使用 DSL 来自动生成 NSError，允许在 Debug 时断言和在 Release 时捕获错误。<a href="https://github.com/krzysztofzablocki/KZAsserts">官网</a></li><li>PSPDFUIKitMainThreadGuard：简洁的代码片段，当 UIKit 在后台线程被使用时生成断言。<a href="https://gist.github.com/steipete/5664345">官网</a></li><li>Flex：一个嵌入 iOS App 的调试和探索工具。<a href="https://github.com/Flipboard/FLEX">官网</a></li><li><a href="http://hao.importnew.com/chisel/">chisel</a>：iOS app 的辅助调试工具，提供了一系列的 LLDB 命令。<a href="https://github.com/facebook/chisel">官网</a></li><li><a href="http://hao.importnew.com/oclint/">OCLint</a>：静态代码分析工具，用以提高代码质量，减少瑕疵。<a href="http://oclint.org/">官网</a></li><li>ocstyle：Objective-C 代码风格检查器。<a href="https://github.com/Cue/ocstyle">官网</a></li><li>SwiftLint：一个实验性的工具，用于强化 Swift 的代码风格和习惯。★<a href="https://github.com/realm/SwiftLint">官网</a></li><li><a href="http://hao.importnew.com/spacecommander/">spacecommander</a>：像一个团队那样，提交完全格式化的 Objective-C 代码。<a href="https://github.com/square/spacecommander">官网</a></li><li>DWURecyclingAlert：优化 UITableViewCell 的滚动流畅性。<a href="https://github.com/diwu/DWURecyclingAlert">官网</a></li><li>DCIntrospect：小型的 iOS 可视化调试工具库。<a href="https://github.com/domesticcatsoftware/DCIntrospect">官网</a></li><li>Watchdog：一个用于记录阻塞主线程的过重任务的类。★<a href="https://github.com/wojteklu/Watchdog">官网</a></li><li>Tailor：跨平台的 Swift 代码静态分析器，它帮助你编写更加清洁的代码，避免 bug。<a href="https://tailor.sh/">官网</a></li><li>SwiftCop：SwiftCop 是一个很实用的格式验证库，灵感来自 Ruby On Rails 清晰的活动记录验证。★<a href="https://github.com/andresinaka/SwiftCop">官网</a></li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a><a name="analytics"></a>分析</h3><ul><li>Flurry Analytics：免费的 App 分析 API。<a href="http://www.flurry.com/">官网</a></li><li>Parse Analytics：测量 App 的使用情况，跟踪 bug 等等。<a href="https://parse.com/products/analytics">官网</a></li><li>Mixpanel：高级分析平台。<a href="https://mixpanel.com/">官网</a></li><li>Localytics：将 app 的营销和数据分析结合起来。<a href="http://www.localytics.com/">官网</a></li><li>Answers by Fabric：让你实时的洞悉用户体验。<a href="https://answers.io/">官网</a></li><li>Liquid Analytics：通过分析和个性化的实时反馈辨认特定的行为。<a href="https://onliquid.com/">官网</a></li><li>GTrack：Google Analytics 对 iOS 的轻量级 Objective-C 封装，并且提供了一些额外的功能。<a href="https://github.com/gemr/GTrack">官网</a></li><li>ARAnalytics：抽象的分析框架，提供了聪明的 API 来跟踪事件和用户数据。<a href="https://github.com/orta/ARAnalytics">官网</a></li><li>Segment：将分析继承进 iOS 应用中的简单方式。<a href="https://github.com/segmentio/analytics-ios">官网</a></li></ul><h3 id="支付"><a href="#支付" class="headerlink" title="支付"></a><a name="payments"></a>支付</h3><ul><li>Stripe：将 Apple Pay 支付继承到你的应用中。很适合那些缺少后台知识的开发者。<a href="https://stripe.com/">官网</a></li><li>Braintree：提供 5 万美金的免费支付额度，需要后台支持。<a href="https://www.braintreepayments.com/">官网</a></li><li>Venmo：在你的应用中支持和接受通过 Venmo 的支付。<a href="https://github.com/venmo/venmo-ios-sdk">官网</a></li><li>Moltin：使用简单的 SDK 为应用添加 eCommerce，你可以创建一个销售产品的商店，不需要后端支持。<a href="https://moltin.com/ios-ecommerce-sdk">官网</a></li></ul><h3 id="生产力"><a href="#生产力" class="headerlink" title="生产力"></a><a name="products"></a>生产力</h3><ul><li>Import.io：将网页即时转换为数据。<a href="https://import.io/">官网</a></li><li>Tapglue：是用很少的代码来构建社交产品和活动的 feed。<a href="https://www.tapglue.com/">官网</a></li></ul><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a><a name="utility"></a>工具</h3><ul><li>Underscore.m：用来操作数据的 DSL。<a href="https://github.com/robb/Underscore.m">官网</a></li><li>SBConstants：生成一个包含了 storyboard 中所有 identifier 的常量文件。<a href="https://github.com/paulsamuels/SBConstants">官网</a></li><li>XExtensionItem：方便地在 iOS 应用和分享扩展至简分享数据。<a href="https://github.com/tumblr/XExtensionItem">官网</a></li><li>ReflectableEnum：Objective-C 枚举的反射。<a href="https://github.com/fastred/ReflectableEnum">官网</a></li><li>VWWPermissionKit：可视化的 iOS 权限管理器。<a href="https://github.com/zakkhoyt/VWWPermissionKit">官网</a></li><li>ClusterPrePermissions：可重用的预授权工具，它可以让开发者在对话中获取系统权限之前询问用户。<a href="https://github.com/clusterinc/ClusterPrePermissions">官网</a></li><li>DateTools：简便的 Objective-C 日期和时间工具。<a href="https://github.com/MatthewYork/DateTools">官网</a></li><li>EKAlgorithms：一些知名的计算机科学算法和数据结构的 Objective-C 实现。<a href="https://github.com/EvgenyKarkan/EKAlgorithms">官网</a></li><li>Tactile：安全并且更加合乎习惯的响应收拾和控件事件的方式。★<a href="https://github.com/delba/Tactile">官网</a></li><li>Colours：这是一套与定义的颜色和颜色方法，让你的 iOS／OS X 开发更加方便。<a href="https://github.com/bennyguitar/Colours">官网</a></li><li>ObjectiveSugar：Ruby 风格的 ObjectiveC 附件。<a href="https://github.com/supermarin/ObjectiveSugar">官网</a></li><li>GroundControl：iOS 远程配置。<a href="https://github.com/mattt/GroundControl">官网</a></li><li>OpinionatedC：让 Objective-C 继承更多 Smalltalk 特性。<a href="https://github.com/leoschweizer/OpinionatedC">官网</a></li><li>GCDKit：GCD 的 Swift 简化版。★<a href="https://github.com/JohnEstropia/GCDKit">官网</a></li><li>SwiftRandom：随即数据生成器。★<a href="https://github.com/thellimist/SwiftRandom">官网</a></li><li>RandomKit：Swift 随机数据生成器。★<a href="https://github.com/nvzqz/RandomKit/">官网</a></li><li>Async：Swift 的 GCD 异步派发语法糖。★<a href="https://github.com/duemunk/Async">官网</a></li><li>YOLOKit：让方块透过圆洞。<a href="https://github.com/mxcl/YOLOKit">官网</a></li><li>EZSwiftExtensions：:smirk:标准类型和类是如何工作的。★<a href="https://github.com/goktugyil/EZSwiftExtensions">官网</a></li><li>ChineseIDCardOCR: 利用前馈神经网络对身份证信息做OCR识别。 ★ <a href="https://github.com/KevinGong2013/ChineseIDCardOCR">官网</a></li></ul><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a><a name="security"></a>安全</h3><ul><li>UICKeyChainStore：UICKeyChainStore 是一个对 Keychain 的简洁封装。<a href="https://github.com/kishikawakatsumi/UICKeyChainStore">官网</a></li><li>cocoapods-keys：一个用来存储环境和应用键值的键值存储。<a href="https://github.com/orta/cocoapods-keys">官网</a></li><li>Valet：在 iOS 和 OS X 的 Keychain 中安全地存储数据，然而你无需知道 keychain 的具体工作细节。<a href="https://github.com/square/Valet">官网</a></li><li>libextobjc：一个用于扩展 Objective-C 编程语言的 Cocoa。<a href="https://github.com/jspahrsummers/libextobjc">官网</a></li><li>Locksmith：方便 Keychain 使用的强大的 Swift 面向协议库。★<a href="https://github.com/matthewpalmer/Locksmith">官网</a></li><li>simple-touch：非常简单的生物识别认证服务（Touch ID）的 Swift 封装。<a href="https://github.com/simple-machines/simple-touch">官网</a></li></ul><h1 id="项目安装"><a href="#项目安装" class="headerlink" title="项目安装"></a><a name="project-setup"></a>项目安装</h1><ul><li>crafter：这是一个允许你使用自定义的领域专用语言（DSL）语法来配置你的 iOS 项目模版的命令行工具（CLI），使用简单但性能强大。<a href="https://github.com/krzysztofzablocki/crafter">官网</a></li><li>liftoff：另一个用于创建 iOS 项目的 CLI。<a href="https://github.com/thoughtbot/liftoff">官网</a></li><li>KZBootstrap：iOS 项目的 bootstrap，目的是高质量的编码。<a href="https://github.com/krzysztofzablocki/KZBootstrap">官网</a></li><li>amaro：优秀的 iOS 样板。<a href="https://github.com/crushlovely/Amaro">官网</a></li><li>chairs：交换你的 iOS 模拟器文档。<a href="https://github.com/orta/chairs">官网</a></li><li><a href="http://hao.importnew.com/darling/">Darling</a>：在 Linux 运行 OS X 二进制文件。<a href="http://www.darlinghq.org/">官网</a>、<a href="https://github.com/LubosD/darling">GitHub</a></li></ul><h1 id="依赖-包管理"><a href="#依赖-包管理" class="headerlink" title="依赖 &#x2F; 包管理"></a><a name="dependency--package-manager"></a>依赖 &#x2F; 包管理</h1><ul><li>Cocoa Pods：CocoaPods 是一个 Objective-C 项目的依赖管理工具。它拥有成千上万个库，它们可以使你的项目更加优雅。<a href="https://cocoapods.org/">官网</a></li><li>Xcode Maven：Xcode Maven 插件，它可以将 Xcode 构建过程嵌入 Maven 的生命周期中。<a href="http://sap-production.github.io/xcode-maven-plugin/site/">官网</a></li><li>Gradle：Xcode 的 gradle 插件，可以使用 gradle 来构建 iOS 或者 Mac OS X 项目。<a href="http://openbakery.org/gradle.html">官网</a></li><li>Carthage：简单的分布式的 Cocoa 依赖管理器。★<a href="https://github.com/Carthage/Carthage">官网</a></li><li>SWM (Swift Modules)：一个类似 npm（node.js的包管理器）或者 bower（Twitter 的浏览器的包管理器） 的 Swift 项目的包／依赖管理器，无需使用 Xcode。★<a href="https://github.com/jankuca/swm">官网</a></li><li>Alcatraz：Xcode 包管理工具.<a href="http://alcatraz.io/">官网</a></li><li>CocoaSeeds：Cocoa 的 Git 子模块替代品。<a href="https://github.com/devxoul/CocoaSeeds">官网</a></li></ul><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a><a name="testing"></a>测试</h1><h3 id="测试驱动开发／行为驱动开发（TDD-BDD）"><a href="#测试驱动开发／行为驱动开发（TDD-BDD）" class="headerlink" title="测试驱动开发／行为驱动开发（TDD &#x2F; BDD）"></a><a name="tdd--bdd"></a>测试驱动开发／行为驱动开发（TDD &#x2F; BDD）</h3><ul><li>Kiwi：一个用于 iOS 开发的 BDD 库。<a href="https://github.com/kiwi-bdd/Kiwi">官网</a></li><li>Specta：轻量级 TDD &#x2F; BDD Objective-C &amp; Cocoa 开发框架。<a href="https://github.com/specta/specta">官网</a></li><li>Quick：Swift 和 Objective-C 的 BDD 框架。<a href="https://github.com/Quick/Quick">官网</a></li><li>XcodeCoverage：Xcode 项目代码覆盖率。<a href="https://github.com/jonreid/XcodeCoverage">官网</a></li><li>OHHTTPStubs：方便地为你的网络请求做存根（Stub）! 使用网络假数据测试你的 app ，你也可以自定义响应时间，响应代码和响应头！<a href="https://github.com/AliSoftware/OHHTTPStubs">官网</a></li><li>Dixie：Dixie 是一个开源的 Objective-C 测试框架。用于改变对象的行为。<a href="https://github.com/Skyscanner/Dixie">官网</a></li><li>gh-unit：Objective-C 的测试框架。<a href="https://github.com/gh-unit/gh-unit">官网</a></li><li>LayoutTest-iOS：一个测试视图的布局的框架，支持多种配置。<a href="https://github.com/linkedin/LayoutTest-iOS">官网</a></li></ul><h3 id="UI-测试"><a href="#UI-测试" class="headerlink" title="UI 测试"></a><a name="ui-testing"></a>UI 测试</h3><ul><li>CrashMonkey：iOS 平台的 Monkey 测试工具。<a href="https://github.com/mokemokechicken/CrashMonkey">官网</a></li><li>appium：Appium 是一个开源自动化测试框架。用于测试原生或者混合 app。<a href="http://appium.io/">官网</a></li><li>robotframework-appiumlibrary：AppiumLibrary 是一个用于 RobotFramwork 的 appium 测试框架。<a href="https://github.com/jollychang/robotframework-appiumlibrary">官网</a></li><li>Cucumber：iOS BDD 框架。<a href="https://cucumber.io/">官网</a></li><li>Kif：一个 iOS 的函数式测试框架。<a href="https://github.com/kif-framework/KIF">官网</a></li><li>Subliminal：一个保守的 iOS 集成测试框架。<a href="https://github.com/inkling/Subliminal">官网</a></li><li>UIAutomation：一个使用脚本在连接着的设备上测试你的用户界面元素的 JavaScript 库。<a href="https://developer.apple.com/library/ios/documentation/DeveloperTools/Reference/UIAutomationRef/">官网</a></li><li>ios-driver：使用 Selenium &#x2F; WebDriver 测试任何 iOS 原生，混合或者移动 web 应用。<a href="http://ios-driver.github.io/ios-driver/index.html">官网</a></li><li>Zucchini：可视化的 iOS 测试框架。<a href="https://github.com/zucchini-src/zucchini">官网</a></li><li>Remote：在 Xcode 内部控制你的 iPhone 来做端到端的测试。<a href="https://github.com/johnno1962/Remote">官网</a></li></ul><h3 id="其他测试"><a href="#其他测试" class="headerlink" title="其他测试"></a><a name="other-testing"></a>其他测试</h3><ul><li>NaughtyKeyboard：一个危险字符串的大列表，当用户输入这些字符串使有很大的可能会造成 bug，这是一个用于在你的 iOS 设备上测试你 app 的键盘。<a href="https://github.com/Palleas/NaughtyKeyboard">官网</a></li><li>PonyDebugger：使用 Chrome 开发者工具对你的 iOS app 进行远程网络和数据调试。<a href="https://github.com/square/PonyDebugger">官网</a></li><li>ios-snapshot-test-case：使用屏幕快照的 iOS 单元测试。<a href="https://github.com/facebook/ios-snapshot-test-case">官网</a></li></ul><h3 id="Beta-测试版本发布"><a href="#Beta-测试版本发布" class="headerlink" title="Beta 测试版本发布"></a><a name="beta-distribution"></a>Beta 测试版本发布</h3><ul><li>Crashlytics：一个崩溃报告和 beta 测试服务。<a href="https://try.crashlytics.com/">官网</a></li><li>TestFlight Beta Testing：iTunes Connect 支持的 beta 测试服务。<a href="https://developer.apple.com/testflight/">官网</a></li><li>HockeyApp：在 HockeyApp 你可以发布你 app 的 beta 测试版本，收集实时的崩溃报告，获取用户反馈，分析测试覆盖率。<a href="http://hockeyapp.net/">官网</a></li><li>boarding：即时为 TestFlight beta 测试者创建简单的注册页面。<a href="https://github.com/fastlane/boarding">官网</a></li></ul><h1 id="工具链"><a href="#工具链" class="headerlink" title="工具链"></a><a name="toolchains"></a>工具链</h1><ul><li>RubyMotion：RubyMotion 是一个革命性的工具链。它可以让你快速地开发和测试原生 iOS 和 OS X 应用，全部使用 Ruby 语言。<a href="http://www.rubymotion.com/">官网</a></li></ul><h1 id="工具-1"><a href="#工具-1" class="headerlink" title="工具"></a><a name="tools"></a>工具</h1><ul><li>Shark：用于将 .xcassets 文件夹转换成一个类型安全枚举的 Swift 脚本。★<a href="https://github.com/kaandedeoglu/Shark">官网</a></li><li>R.swift：在 Swift 项目中，强类型的自动补全资源名称的工具，包括图片，单元格和 segue 的工具。★<a href="https://github.com/mac-cain13/R.swift">官网</a></li><li>SwiftGen：一个生成 Swift 代码工具的集合（生成资源的枚举，storyboard，本地化字符串和 UIColor）。★<a href="https://github.com/AliSoftware/SwiftGen">官网</a></li><li>Localize-Swift：Swift 2.0 实现在应用中切换语言的功能，帮助你的 APP 实现友好的本地化和国际化。★<a href="https://github.com/marmelroy/Localize-Swift">官网</a></li><li>Blade：为 iOS 和 OS X 应用生成 Xcode 图片目录，全局图片和其他相关的东西。<a href="https://github.com/jondot/blade">官网</a></li><li>Retini：一个超级简单的 Retina（2x，3x）图片转换器。<a href="https://github.com/terwanerik/Retini">官网</a></li><li>Provisioning：一个查看器插件，用于预览 .mobileprovision 文件。<a href="https://github.com/chockenberry/Provisioning">官网</a></li><li>Strsync：自动翻译并且使 .strings 文件和默认语言同步。<a href="https://github.com/metasmile/strsync">官网</a></li><li><a href="http://hao.importnew.com/laptop/">Laptop</a>：一个让Mac OS X或Linux更智能的shell脚本。<a href="https://thoughtbot.com/open-source">官网</a> <a href="https://github.com/thoughtbot/laptop">Github</a></li><li>DoraemonKit: 一款功能齐全的iOS研发助手，你值得拥有。<a href="https://www.dokit.cn/">官网</a> <a href="https://github.com/didi/DoraemonKit">Github</a></li></ul><h1 id="快速开发"><a href="#快速开发" class="headerlink" title="快速开发"></a><a name="rapid-development"></a>快速开发</h1><ul><li>KZPlayground：Objective-C 版本的 Playground。<a href="https://github.com/krzysztofzablocki/KZPlayground">官网</a></li><li>dyci：代码注入工具。<a href="https://github.com/DyCI/dyci-main">官网</a></li><li>injectionforxcode：代码注入，支持 Swift。<a href="https://github.com/johnno1962/injectionforxcode">官网</a></li><li>MMBarricade：在运行时为 iOS app 配置本地服务器。<a href="https://github.com/mutualmobile/MMBarricade">官网</a></li><li>NetworkObjects：根据你的 Core Data 模型生成 RESTful 服务器。<a href="https://github.com/colemancda/NetworkObjects">官网</a></li><li>STV Framework：开发原生 iOS app 的可视化开发工具。<a href="http://www.sensiblecocoa.com/">官网</a></li></ul><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a><a name="deployment"></a>部署</h1><ul><li><a href="https://github.com/fastlane/fastlane">fastlane</a> 将所有 iOS 部署工具整合到一个工作流中。</li><li><a href="https://github.com/fastlane/deliver">deliver</a> 部署截屏，app 元数据和 AppStore app 更新，这一切只需要一个命令就可以搞定。</li><li><a href="https://github.com/fastlane/snapshot">snapshot</a> 自动地创建全部语言和全部设备的屏幕截图。</li></ul><h1 id="App-Store"><a href="#App-Store" class="headerlink" title="App Store"></a><a name="app-store"></a>App Store</h1><ul><li><a href="http://appreviewtimes.com/">Average App Store Review Times</a> 这个网站可以同时跟踪 AppStore 上 iOS 和 Mac 两个版本的浏览次数，使用了利用 iOS 和 Mac 开发者的众包数据。</li><li><a href="https://developer.apple.com/app-store/review/rejections/">Apple’s Common App Rejections Styleguide</a> 一些导致 app 被苹果拒绝的重要常见问题。</li><li><a href="https://www.mobileaction.co/">Free App Store Optimization Tool</a> 在关键字和竞争者的角度上，让你可视化地追踪你的 App Store 数据。</li></ul><h1 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a><a name="sdk"></a>SDK</h1><h2 id="官方的"><a href="#官方的" class="headerlink" title="官方的"></a>官方的</h2><ul><li><a href="https://github.com/spotify/ios-sdk">Spotify</a>：Spotify iOS SDK。</li><li><a href="https://github.com/facebook/facebook-ios-sdk">Facebook</a>：Facebook iOS SDK。</li><li><a href="https://developers.google.com/analytics/devguides/collection/ios/v3/">Google Analytics</a>：Google Analytics iOS SDK。</li><li><a href="https://github.com/paypal/PayPal-iOS-SDK">Paypal iOS SDK</a>：The PayPal 移动端 SDK，可以简便地在本地应用中集成 PayPal 和 信用卡支付。</li><li><a href="https://github.com/Pocket/Pocket-ObjC-SDK">Pocket</a>：将东西保存到 Pocket 的 SDK。</li><li><a href="https://github.com/tumblr/TMTumblrSDK">Tumblr</a>：集成 Tumblr 数据到 iOS 或 OS X 应用中的库。</li><li><a href="https://github.com/evernote/evernote-cloud-sdk-ios">Evernote</a>：Evernote iOS SDK。</li><li><a href="https://github.com/box/box-ios-sdk">Box</a>：Box iOS 和 OS X SDK API。</li><li><a href="https://github.com/OneDrive/onedrive-sdk-ios">OneDrive</a>：Live iOS SDK。</li><li><a href="https://github.com/stripe/stripe-ios">Stripe</a>：iOS and OS X Stripe 绑定框架。</li><li><a href="https://github.com/venmo/venmo-ios-sdk">Venmo</a>：在你的 iOS app 通过 Venmo 生成订单并且接受支付。</li><li><a href="https://github.com/aws/aws-sdk-ios">AWS</a>：Amazon Web Services iOS 移动应用 SDK。</li><li><a href="https://github.com/zendesk/zendesk_sdk_ios">Zendesk</a>：Zendesk iOS 移动应用 SDK。</li><li><a href="https://creativesdk.adobe.com/">Adobe Creative SDK</a>：Adobe creative tools 和 Creative Cloud SDK。</li><li><a href="https://www.dropbox.com/developers">Dropbox</a>：Drop-ins 和 Dropbox Core API 的 SDK。</li><li><a href="https://docs.fabric.io/ios/index.html">Fabric by Twitter</a>：iOS 的 Fabric Twitter Kit。</li><li><a href="https://github.com/lqd-io/liquid-sdk-ios">Liquid Analytics</a>：通过分析与实时的个性化的实时响应产生特定的行为。</li><li><a href="https://github.com/ResearchKit/ResearchKit">ResearchKit</a>：ResearchKit 是一个开源的软件框架，用它可方便的构建医疗研究应用或者其他的研究项目。</li><li><a href="https://packetzoom.com/">PacketZoom</a>：PacketZoom iOS SDK。</li><li>Primer：在可视化编辑器上方便创建定制化的登陆页，注册和登录流程的 SDK，内建了 a&#x2F;b&#x2F;n 测试和分析。<a href="https://www.goprimer.com/">官网</a></li></ul><h2 id="非官方"><a href="#非官方" class="headerlink" title="非官方"></a>非官方</h2><ul><li>STTwitter：为 Twitter REST API 1.1 制作的稳定，成熟，全面的 Objective-C 库。<a href="https://github.com/nst/STTwitter">官网</a> </li><li>FHSTwitterEngine：为 Cocoa 开发者提供的 Twitter API。<a href="https://github.com/fhsjaagshs/FHSTwitterEngine">官网</a> </li><li>Giphy： Giphy API 的 Objective-C iOS 客户端。<a href="https://github.com/heyalexchoi/Giphy-iOS">官网</a></li><li>UberKit：Objective-C 包装的简单易用的 Uber API。<a href="https://github.com/sachinkesiraju/UberKit">官网</a></li><li>InstagramKit：Instagram iOS SDK。<a href="https://github.com/shyambhat/InstagramKit">官网</a></li><li>DribbbleSDK：Dribbble iOS SDK。<a href="https://github.com/agilie/dribbble-ios-sdk">官网</a></li><li>objectiveflickr：对象化的 Flickr， Objective-C 写的 Flickr API。<a href="https://github.com/lukhnos/objectiveflickr">官网</a></li><li>DropletKit：Objective-C 包装的 DigitalOcean v2 API。<a href="https://github.com/victorgama/DropletKit">官网</a></li></ul><h1 id="Xcode"><a href="#Xcode" class="headerlink" title="Xcode"></a><a name="xcode"></a>Xcode</h1><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a><a name="plugins"></a>插件</h3><ul><li>FuzzyAutocompletePlugin：提供了除前缀匹配之外的其他更加灵活的自动补全功能，支持 Xcode 5+。<a href="https://github.com/FuzzyAutocomplete/FuzzyAutocompletePlugin">官网</a></li><li>SCXcodeMiniMap：SCXcodeMiniMap 为 Xcode 添加了代码地图功能<a href="https://github.com/stefanceriu/SCXcodeMiniMap">官网</a></li><li>Show in Github：可以直接打开 Github 上当前正在编辑的行对应的 commit 页面。<a href="https://github.com/larsxschneider/ShowInGitHub">官网</a></li><li>BBUFullIssueNavigator：这个插件让 Xcode 在 issue 导航栏显示所有的 issue 内容。<a href="https://github.com/neonichu/BBUFullIssueNavigator">官网</a></li><li>BBUDebuggerTuckAway：当你开始编辑的时候帮你隐藏调试器栏的 Xcode 插件。<a href="https://github.com/neonichu/BBUDebuggerTuckAway">官网</a></li><li>SCXcodeSwitchExpander：SCXcodeSwitchExpander 是一个可以帮你展开 switch 语句的插件，还会自动帮你插入 case 语句。<a href="https://github.com/stefanceriu/SCXcodeSwitchExpander">官网</a></li><li>VVDocumenter-Xcode：方便的编写标准注释的 Xcode 插件。<a href="https://github.com/onevcat/VVDocumenter-Xcode">官网</a></li><li>XAlign：一个 Xcode 代码自动对齐插件，它可以使用自定义的模式来对齐任何东西。<a href="https://github.com/qfish/XAlign">官网</a></li><li>Cocoapods Xcode Plugin：依赖管理工具 CocoaPods 的 Xcode 插件。<a href="https://github.com/kattrali/cocoapods-xcode-plugin">官网</a></li><li>KSImageNamed-Xcode：提供了图片名称自动补全功能的插件。<a href="https://github.com/ksuther/KSImageNamed-Xcode">官网</a></li><li>ColorSense-for-Xcode：可视化的颜色选择插件。<a href="https://github.com/omz/ColorSense-for-Xcode">官网</a></li><li>Backlight-for-XCode：高亮当前编辑的行。<a href="https://github.com/limejelly/Backlight-for-XCode">官网</a></li><li>UIColor-Hex-Swift：通过十六进制字符串创建 autorelease 颜色的便利方法。★<a href="https://github.com/yeahdongcn/UIColor-Hex-Swift">官网</a></li><li>KPRunEverywhereXcodePlugin：只需一次点击，就可以在多个 iOS 设备上构建，运行 App。<a href="https://github.com/kitschpatrol/KPRunEverywhereXcodePlugin">官网</a></li><li>RevealPlugin：将 Reveal App 和你的项目自动合为一体的 Xcode 插件。<a href="https://github.com/shjborage/Reveal-Plugin-for-Xcode">官网</a></li><li>RealmPlugin：生成 Realm 模型的 Xcode 插件。<a href="https://realm.io/docs/objc/0.81.0/#xcode-plugin">官网</a></li><li>AdjustFontSize：使用 <code>⌘ +</code> &#x2F; <code>⌘ -</code> 快捷键调整字体大小。<a href="https://github.com/zats/AdjustFontSize-Xcode-Plugin">官网</a></li><li>Lin：这个插件提供了 NSLocalizedString 的自动补全插件。<a href="https://github.com/questbeat/Lin">官网</a></li><li>Rephrase：Xcode 用于本地化的插件.<a href="https://www.rephrase.io/">官网</a></li><li>XCActionBar：Xcode 的 Alfred。<a href="https://github.com/pdcgomes/XCActionBar">官网</a></li><li>QuickJump：Xcode 快速代码导航。<a href="https://github.com/wiruzx/QuickJump">官网</a></li><li>CATweaker：一个用于创建漂亮的 CAMediaTimingFunction 曲线的插件.<a href="https://github.com/keefo/CATweaker">官网</a></li><li>XcodeWay：便捷地导航到多个地方。<a href="https://github.com/onmyway133/XcodeWay">官网</a></li><li>GitDiff：将与 git 仓库中不同的代码高亮。<a href="https://github.com/johnno1962/GitDiff">官网</a></li><li>MCLog：用于控制台内容筛选的插件。<a href="https://github.com/yuhua-chen/MCLog">官网</a></li><li>XToDo：一个显示项目中 TODO，FIXME，??? 和 !!! 列表的对话框。<a href="https://github.com/trawor/XToDo">官网</a></li><li>CopyIssue：使复制 Xcode issuse 描述更简单。<a href="https://github.com/hanton/CopyIssue-Xcode-Plugin">官网</a></li><li>RTImageAssets：自动生成所需的全部 App 图标的插件。<a href="https://github.com/rickytan/RTImageAssets">官网</a></li><li>BBUncrustifyPlugin-Xcode：使用 ClangFormat 或 Uncrustify 格式化代码的插件。<a href="https://github.com/benoitsan/BBUncrustifyPlugin-Xcode">官网</a></li><li>Aviator：这个插件将 AppCode 的 ⇧⌘T (source&#x2F;test 切换) 带到 Xcode 中.<a href="https://github.com/marksands/Aviator">官网</a></li><li>JumpMarks：使用有序的书签为你的代码做导航。<a href="https://github.com/merrickp/JumpMarks">官网</a></li><li>XCSnippetr：直接上传代码片段到 Slack 和 Gist 的 Xcode 插件。<a href="https://github.com/dzenbot/XCSnippetr">官网</a></li><li>Peckham：使用 #import 引用项目中的任何文件，提供代码提示。<a href="https://github.com/markohlebar/Peckham">官网</a></li><li>MLAutoReplace：快速编码以及代码格式化插件，提升你的编码速度。<a href="https://github.com/molon/MLAutoReplace">官网</a></li><li>Chameleon：iOS （Obj-C &amp; Swift）的扁平化颜色框架。★<a href="https://github.com/ViccAlexander/Chameleon">官网</a></li><li>AutoHighlightSymbol：高亮被选中的符号对应的所有实例。<a href="https://github.com/chiahsien/AutoHighlightSymbol">官网</a></li><li>Reveal-In-GitHub：用一个快捷键就可以跳转到 GitHub 仓库的 History, Blame, PRs, Issues, Notifications。<a href="https://github.com/lzwjava/Reveal-In-Github">官网</a></li><li>CleanHeaders-Xcode：类似 iSort 的头文件排序和重复消除插件，让你的头文件看起来更加有序。<a href="https://github.com/insanoid/CleanHeaders-Xcode">官网</a></li><li>Luft：帮助你实现轻量的 View Controller 的 Xcode 插件。<a href="https://github.com/k0nserv/luft">官网</a></li></ul><h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a><a name="themes"></a>主题</h3><ul><li>Dracula Theme：一个 Xcode 的暗色主题（仿 SublimeText）.<a href="https://github.com/zenorocha/dracula-theme">官网</a></li><li>Xcode themes list：Xcode 的多彩主题。<a href="https://github.com/hdoria/xcode-themes">官网</a></li><li>Solarized-Dark-for-Xcode：用于 Xcode5 的 Solarized Dark 主题.<a href="https://github.com/ArtSabintsev/Solarized-Dark-for-Xcode/">官网</a></li></ul><h3 id="其他-Xcode-插件"><a href="#其他-Xcode-插件" class="headerlink" title="其他 Xcode 插件"></a><a name="other-xcode"></a>其他 Xcode 插件</h3><ul><li>Synx：一个重新组织你的 Xcode 项目的命令行工具，它能够让你的 group 和文件夹对应起来。<a href="https://github.com/venmo/synx">官网</a></li><li>dsnip：可以在本地为所有的 UIKit 协议／代理方法（UITableView,…）生成 Xcode 代码片段的工具。<a href="https://github.com/Tintenklecks/IBDelegateCodesippets">官网</a></li></ul><h1 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a><a name="style-guides"></a>编码规范</h1><ul><li><a href="https://github.com/NYTimes/objective-c-style-guide">NY Times：Objective C Style Guide</a>：纽约时报使用的 Objective-C 编码规范。</li><li><a href="https://github.com/raywenderlich/objective-c-style-guide">raywenderlich Style Guide</a>：一个描述 raywenderlich.com 编码习惯的代码规范。</li><li><a href="https://github.com/github/objective-c-style-guide">Github Objective-C Style Guide</a>：Objective-C 项目的编码规范和惯用法。</li><li><a href="https://gist.github.com/soffes/812796">Objective-C Coding Convention and Best Practices</a>：一份描述编码习惯的 Gist。</li><li><a href="https://github.com/raywenderlich/swift-style-guide">Swift Style Guide by @raywenderlich</a>：raywenderlich.com 官方的 Swift 编码风格规范。★</li><li><a href="https://github.com/spotify/ios-style">Spotify Objective-C Coding Style</a>：Spotify 的 iOS 开发指导。</li><li><a href="https://dl.dropboxusercontent.com/s/5utnlwhr18ax05c/style-guide.html?dl=0">Dropbox Objective-C Style Guide</a>：Dropbox 的 Objective-C 代码风格指南。</li><li><a href="https://github.com/github/swift-style-guide">Github：Style guide &amp; coding conventions for Swift projects</a>：github 的 Swift 编码风格和习惯指南。★</li><li><a href="https://github.com/futurice/ios-good-practices">Futurice iOS Good Practices</a>：<a href="https://github.com/futurice">@futurice</a> 介绍的 iOS 入门指南和最佳实践。</li></ul><h1 id="好网站"><a href="#好网站" class="headerlink" title="好网站"></a><a name="good-websites"></a>好网站</h1><h3>中文站点</h3><ul><li>伯乐在线 iOS 频道：分享 iOS 和 Swift 开发，应用设计和推广，iOS 相关的行业动态。<a href="http://ios.importnew.com/">官网</a></li></ul><h3>英文站点</h3>### <a name="news-blogs-and-more"></a>新闻，播客和其他<ul><li><a href="http://bgr.com/ios-7/">BGR</a></li><li><a href="http://www.imore.com/">iMore</a></li><li><a href="http://lifehacker.com/tag/ios">Lifehacker</a></li><li><a href="http://www.icodeblog.com/">iCode Blog</a></li><li><a href="http://nshipster.com/">NSHipster</a></li><li><a href="https://www.objc.io/">Objc.io</a></li><li><a href="http://asciiwwdc.com/">ASCIIwwdc</a></li><li><a href="https://natashatherobot.com/">Natasha The Robot</a></li><li><a href="https://developer.apple.com/swift/blog/">Apple’s Swift Blog</a> ★</li><li><a href="https://www.reddit.com/r/iosprogramming">iOS Programming Subreddit</a></li><li><a href="https://iosdevweekly.com/">iOS Dev Weekly</a></li><li><a href="https://github.com/shinobicontrols/iOS8-day-by-day">iOS8-day-by-day</a> ★</li><li><a href="http://www.ioscreator.com/">iOScreator</a> ★</li><li><a href="http://mathewsanders.com/">Mathew Sanders</a> ★</li><li><a href="https://littlebitesofcocoa.com/">Little Bites of Cocoa</a> ★</li><li><a href="http://hboon.com/iosdevnuggets/">iOS Dev Nuggets</a> ★</li><li><a href="http://swiftnews.curated.co/">This Week in Swift</a> ★</li><li><a href="http://ios-goodies.com/">iOS Goodies</a></li><li><a href="https://github.com/CameronBanga/iOS-Developer-and-Designer-Interview-Questions">iOS Developer and Designer interview</a>：一个用于帮助那些寻找 iOS 开发者或设计师的雇主的小指南。</li><li><a href="https://medium.com/ios-os-x-development">iOS App Development on Medium</a>：一些关于 iOS，AppleWatch 开发的小故事和小贴士。</li><li><a href="http://swiftsandbox.io/">Swift Sandbox</a>：Swift 开发者通讯，Swift 开源新闻，项目和资源。 ★</li></ul><h3 id="UIKit-文档"><a href="#UIKit-文档" class="headerlink" title="UIKit 文档"></a><a name="uikit-references"></a>UIKit 文档</h3><ul><li><a href="http://iosfonts.com/">iOS Fonts</a></li><li><a href="https://gist.github.com/mattt/5135521">UIAppearance list</a></li></ul><h3 id="论坛和讨论列表"><a href="#论坛和讨论列表" class="headerlink" title="论坛和讨论列表"></a><a name="forums-and-discuss-lists"></a>论坛和讨论列表</h3><ul><li><a href="http://iphonedevsdk.com/">iPhone Dev SDK Forum</a></li><li><a href="http://stackoverflow.com/questions/tagged/ios">“iOS” on Stackoverflow</a></li></ul><h3 id="教程和-Keynotes"><a href="#教程和-Keynotes" class="headerlink" title="教程和 Keynotes"></a><a name="tutorials-and-keynotes"></a>教程和 Keynotes</h3><ul><li><a href="http://www.appcoda.com/">AppCoda</a></li><li><a href="http://www.tutorialspoint.com/ios/">Tutorials Point</a></li><li><a href="http://codewithchris.com/">Code with Cris</a></li><li><a href="http://www.cocoawithlove.com/">Cocoa with Love</a></li><li><a href="http://www.cimgf.com/">Cocoa is my Girlfriend</a></li><li><a href="http://tryobjectivec.codeschool.com/">Code School：Try Objective-C</a></li><li><a href="https://www.youtube.com/channel/UCysEngjfeIYapEER9K8aikw/videos">Brian Advent youtube channel</a>：Youtube 上的 Swift 教程频道。 ★</li><li><a href="http://www.raywenderlich.com/tutorials">RAYWENDERLICH</a>：开发者和爱好者的教程。</li><li><a href="http://rypress.com/tutorials/objective-c/index">Ry’s Objective-C Tutorial</a></li><li><a href="https://www.mikeash.com/pyblog/">Mike Ash</a></li><li><a href="https://www.bignerdranch.com/blog/categories/ios/">Big Nerd Ranch</a> ★</li><li><a href="http://code.tutsplus.com/categories/ios-sdk">Tuts+</a> ★</li><li><a href="http://www.ios-blog.co.uk/">iOS-Blog</a> ★</li><li><a href="https://thinkster.io/a-better-way-to-learn-swift">Thinkster</a> ★</li><li><a href="https://github.com/swifteducation">Swift Education</a>：一个供教育者分享 Swift 和 app 开发学习材料的社区。★</li><li><a href="http://cocoadevcentral.com/">Cocoa Dev Central</a></li><li><a href="http://useyourloaf.com/">Use Your Loaf</a></li><li><a href="http://jamesonquave.com/blog/tutorials/">Swift Tutorials by Jameson Quave</a> ★</li></ul><h3 id="iOS-UI-模版"><a href="#iOS-UI-模版" class="headerlink" title="iOS UI 模版"></a>iOS UI 模版</h3><ul><li><a href="http://appicontemplate.com/ios8/">App Icon Template</a></li><li><a href="http://www.teehanlax.com/tools/iphone/">iOS 8 GUI PSD Template</a></li><li><a href="http://www.invisionapp.com/tethr">iOS UI Design Kit</a></li><li><a href="http://iosdesign.ivomynttinen.com/">iOS Design Guidelines</a></li></ul><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a><a name="prototyping"></a>原型</h3><ul><li><a href="https://www.fluidui.com/">FluidUI</a></li><li><a href="https://proto.io/">Proto.io</a></li><li><a href="http://framerjs.com/">Framer</a></li><li><a href="http://www.pixate.com/">Pixate</a></li><li><a href="http://principleformac.com/">Principle</a></li></ul><h1 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a><a name="books"></a>书籍</h1><ul><li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/ProgrammingWithObjectiveC.pdf">Programming with Objective-C by Apple</a></li><li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/OOP_ObjC/OOP_ObjC.pdf">Object-Oriented Programming with Objective-C by Apple</a></li><li><a href="https://itunes.apple.com/us/book/swift-programming-language/id881256329?mt=11">The Swift Programming Language by Apple</a> ★</li><li><a href="https://itunes.apple.com/us/book/using-swift-cocoa-objective/id888894773?mt=11">Using Swift with Cocoa and Objective C by Apple</a> ★</li><li><a href="https://www.bignerdranch.com/we-write/ios-programming/">iOS Programming: The Big Nerd Ranch Guide by Christian Keur, Aaron Hillegass, Joe Conway</a></li><li><a href="http://www.amazon.com/Programming-Objective-C-6th-Developers-Library/dp/0321967607">Programming in Objective-C by Stephen G. Kochan</a></li><li><a href="https://leanpub.com/your-first-ios-app">Your First iOS App by Ash Furrow</a></li><li><a href="https://www.mikeash.com/book.html">The Complete Friday Q &amp; A: Volume 1</a></li><li><a href="http://www.amazon.com/Core-Data-iOS-Data-Driven-Applications/dp/0321670426/">Core Data for iOS: Developing Data-Driven Applications for the iPad, iPhone, and iPod touch</a></li><li><a href="http://www.amazon.com/Cocoa-Design-Patterns-Erik-Buck/dp/0321535022">Cocoa Design Patterns</a></li></ul><h1 id="其他优秀的列表"><a href="#其他优秀的列表" class="headerlink" title="其他优秀的列表"></a><a name="other-awesome-lists"></a>其他优秀的列表</h1><p>你可以在下面找到其他十分优秀的列表</p><ul><li><a href="https://github.com/bayandin/awesome-awesomeness">awesome-awesomeness</a> 列表。</li><li><a href="https://github.com/dkhamsing/open-source-ios-apps">Open Source apps</a> 开源 iOS app 列表。</li><li>优秀的 Swift 列表<ul><li><a href="https://github.com/matteocrippa/awesome-swift">@matteocrippa</a>：一个优秀的 Swift 资源合集列表。</li><li><a href="https://github.com/Wolg/awesome-swift">@Wolg</a>：一个很棒的 Swift 框架，库和软件的策划列表。</li></ul></li><li><a href="https://github.com/sanketfirodiya/sample-watchkit-apps">awesome watchkit apps</a> watchkit app 例程和教程的列表。▲</li><li><a href="https://github.com/sanketfirodiya/iOS-learning-resources">iOS Learning Resources</a> 一个高质量，频繁更新并且被很好维护的 iOS 教程网站的完整集合。</li><li><a href="https://github.com/sxyx2008/awesome-ios-animation">awesome-ios-animation</a>：包括了 Objective-C 和 Swift 实现的 iOS 动画库列表。</li><li><a href="https://github.com/sxyx2008/awesome-ios-chart">awesome-ios-chart</a>：很棒的 iOS 图表库列表。包括了 Objective-C 和 Swift 两种语言。</li><li><a href="https://github.com/vsouza/awesome-gists#ios">awesome-gists</a>：很棒的 Gist 列表 (iOS 章节).</li><li><a href="https://github.com/cjwirth/awesome-ios-ui">awesome-ios-ui</a>：优秀的 iOS UI&#x2F;UX 库列表。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS Tips</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Runloop</title>
    <link href="/myblog/2024/10/29/Runloop/"/>
    <url>/myblog/2024/10/29/Runloop/</url>
    
    <content type="html"><![CDATA[<h2 id="Runloop"><a href="#Runloop" class="headerlink" title="Runloop"></a>Runloop</h2><h3 id="简述runloop"><a href="#简述runloop" class="headerlink" title="简述runloop"></a>简述runloop</h3><p>Runloop本质上就是while死循环，有了这个循环就可以确保线程永远不会结束，这个循环通过操作系统底层的函数进行休眠和唤起，以此来节省消耗。</p><p>Runloop主要的工作是接收并处理各种事件，包括创建和销毁自动释放池，处理 点击事件，block回调，倒计时等等。</p><p>一个Runloop包含多个mode, 一个mode又包含多个source，time, observer。</p><p>线程和Runloop是一一对应的，它们的关系被保存在一个全局的Dictionary里。线程创建并不会带有Runloop, 只有在第一次获取时才会创建。当线程结束时销毁Runloop，除了主线程外，只能在线程内部获取对应的Runloop。</p><p>Runloop的使用场景</p><ul><li>NSTime不停止</li><li>线程保活</li><li>界面刷新</li><li>事件响应</li><li>自动释放池的创建和释放</li></ul><h1 id="Runloop和线程的关系"><a href="#Runloop和线程的关系" class="headerlink" title="Runloop和线程的关系"></a>Runloop和线程的关系</h1><ul><li>Runloop是基于线程进行管理的</li><li>主线程默认带有runloop。子线程默认没有，只有当第一次在子线程获取runloop时才回创建runloop.</li><li>runloop和线程是一一对应的，他们之间的映射关系使用一个Dictionary惊醒保存。</li></ul><p>#performSelector:withObject:afterDelay:</p><ul><li>在当前线程执行，不会创建新线程</li><li>实现原理：使用定时器，等待runloop调用</li><li><code>afterDelay</code>参数设置的是最小时间，即使设置为0也不会立即执行<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"> - (<span class="hljs-type">void</span>)viewDidLoad &#123;<br> [<span class="hljs-variable language_">super</span> viewDidLoad];<br> <br> <br> <span class="hljs-comment">/*</span><br><span class="hljs-comment">  下面代码的输出顺序：</span><br><span class="hljs-comment">  1</span><br><span class="hljs-comment">  3</span><br><span class="hljs-comment">  ViewController test</span><br><span class="hljs-comment">  */</span><br>  <br> <span class="hljs-comment">//开始执行</span><br> <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1&quot;</span>);<br>   <br> [<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(test) withObject:<span class="hljs-literal">nil</span> afterDelay:<span class="hljs-number">0</span>];<br>   <br> <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3&quot;</span>);<br> &#125;<br><br>- (<span class="hljs-type">void</span>)test &#123;<br> <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;ViewController test&quot;</span>);<br> &#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="Runloop-自动释放池线程"><a href="#Runloop-自动释放池线程" class="headerlink" title="Runloop 自动释放池线程"></a>Runloop 自动释放池线程</h2><p>一个线程对应一个runloop, 一个runloop中可以有多个自动释放池</p><p>其他</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(test3) withObject:<span class="hljs-literal">nil</span> afterDelay:<span class="hljs-number">0</span>];<br><span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;---111&quot;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><p>会先执行dispath_asyc中的内容，在执行perfirmSelector:withObjct:afterDeley: 中的内容。是因为runloop中会处理GCD再处理定时器。</p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>八股文-Runloop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift</title>
    <link href="/myblog/2024/10/29/Swift/"/>
    <url>/myblog/2024/10/29/Swift/</url>
    
    <content type="html"><![CDATA[<h2 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h2><h3 id="struct-VS-class"><a href="#struct-VS-class" class="headerlink" title="struct VS class"></a>struct VS class</h3><p>struct 是值类型，class 是引用类型</p><h3 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h3><ul><li>值类型不能使用继承体系，引用类型可以。</li><li>值类型：struct、enum, 引用类型： class、close</li><li>let 修饰的值类型不能在初始化之后修改内部的变量的值，引用类型可以</li><li>内存管理<ul><li>值类型的内存分配在栈上，引用类型的内存分配在堆上</li><li>值类型是线程安全的，应为每个线程都有自己的栈，不同线程之间不共享栈信息</li><li>值类型（栈上）不需要引用计数，内存的申请和释放由栈处理，</li><li>所以效率更高、熟读更快</li></ul></li></ul><p>swift中集合使用值类型的原因</p><ul><li>值类型效率高</li><li>值类型线程安全</li></ul><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><ul><li>元组可以存放不同类型的值</li><li>元组不是集合</li><li>元组可以通过映射来进行元素遍历</li><li>元组不能作为字典的key，因为没有实现哈希协议</li><li>元组的内存结构是连续的</li></ul><h2 id="可选型"><a href="#可选型" class="headerlink" title="可选型"></a>可选型</h2><p>可选型是为了表达一个变量为空的情况，在类型后面加问号？来定义可选型，或者直接使用Optional&lt;&gt;</p><p>值类型或者引用类型都可以是可选型变量。</p><p>可选型本质上是一个本质上是一个范性枚举。</p><h2 id="存储属性和计算属性"><a href="#存储属性和计算属性" class="headerlink" title="存储属性和计算属性"></a>存储属性和计算属性</h2><p><strong>存储属性</strong>：存储在示例对象的内存中，类似于成员变量。结构体和类可以定义为存储属性，枚举不可以。</p><p><strong>计算属性</strong>: 本质就是方法，不占用实例对像内存。枚举、结构体、类都可以定义为计算属性。</p><h2 id="延迟存储属性"><a href="#延迟存储属性" class="headerlink" title="延迟存储属性"></a>延迟存储属性</h2><p>使用<code>lazy</code>可以定义延迟存储属性，延迟存储属性不能用于计算属性。</p><p><code>lazy</code>属性必须是<code>var</code>，不能是<code>let</code>。</p><p><strong>如果多条线程访问<code>lazy</code>属性无法保证属性只被初始化一次。</strong></p><h2 id="static和class的区别"><a href="#static和class的区别" class="headerlink" title="static和class的区别"></a><code>static</code>和<code>class</code>的区别</h2><ul><li><code>static</code>可以用在值类型，<code>class</code>不可以</li><li><code>static</code>修饰的不可以被继承，<code>class</code>修饰的可以被继承</li></ul><h2 id="初始化器"><a href="#初始化器" class="headerlink" title="初始化器"></a>初始化器</h2><ul><li>结构体、枚举、类都可以定义初始化器</li><li>初始化器分为：指定初始化器、便捷初始化器</li><li>规则<ul><li>每个类至少有一个指定初始化器，指定初始化器是类的主要初始化器</li><li>默认初始化器纵使指定初始化器</li><li>指定初始化器必须从他的直系父类调用指定初始化器</li><li>便捷初始化器必须调用当前类的另一个初始化器</li><li>便捷初始化器最终必须调用一个指定初始化器</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>八股文-Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/myblog/2024/10/29/hello-world/"/>
    <url>/myblog/2024/10/29/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
